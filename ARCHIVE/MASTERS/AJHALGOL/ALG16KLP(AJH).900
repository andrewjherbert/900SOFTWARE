
((Improved ALGOL Large Program System - Andrew Herbert 22/03/2015))


(Derived from reconstructed Issue 6 LP System, modified to include
  1.  Don Hunter's extensions - call by name and recursive procedures
  2.  Andrew Herbert's fixes/improvements to Don's extensions
  3.  Terry Froggatt's 900 telecode support [alternative quote/unquote
      characters, new and old pound signs]
  4.  Terry Froggatt's improved relational and boolean operator primitives
  5.  Terry Froggatt's fixed/improved integer divide code
  6.  Removal of redundant code [mostly FAS related].)

(Assemble with MASIR)

(REMEMBER TO SET ENDLIB TO AFTER LITERALS)

*PROG INTERP
*LISTLA
*NOMEM

((ALGOL 16K LP System Interpreter))


^8

[ ALRMCH ALGFLG BASE BEGLOA BLANK BUFFER FAILEN DEV DLDIV DLMULT DUMP DFLAG
ENDLIB FLNS14 FLNS15 FPA GECHAR GECHEN GECH GLOPMD HALTCH HALTMK IDEV INPA
INSLOT IOLNK LA LFCH LIBRY LLDR1 LLDR1A LPCTL LPSYMS NEXTCH NXPORD ODEV OLDLBD
OSTSB OTCHA OTCHA1 OTCHA2 OUTI OUTPA OUTSLT PAUSRT PCHLNK READAL SBLNK SBLNK2
SBW SBW4 SBW5 SERIES SP STAND STKBAS STKMOD T23LEN TABLE THUNK WARNAD W1 W3 W4
WS ]

( 8)      8     ENT8      (Load ALGOL maintaining libraries & code procedures)
( 9)      8     ENT9      (Load overwriting code procedures but not library)
(10)      8     ENT10     (Load overwriting libraries and code procedures)
(11)      8     ENT11     (Load additional code procedure)
(12)      8     ENT12     (Load additional code procedure replacing all
 	  		      others)
(13)      8     ENT13     (load new library overwriting existing library and
                               code procedures)
(14)      8     DUMP      (dump system)

SDEV      >1
EVN       >1              (16, 17, 18, 19 get zapped by MASIR loader)
LOC       >1
MKR7      >1
COUNT     >1

(code to read D or R)
LPCTL     4     DEV       (save input device)
          5     SDEV
          4     +PROMPT
          11    SBLNK2
          8     OSTSB
          4     SDEV      (restore input device)
          5     DEV
          4     +0
          15    2052
          1     -68       (is it 'D'?)
          7     LETD
          2     +127
          7     ;+4       (is it 'C'?)
          1     +15       (is it 'R'?)
          7     RUNALG
          8     LPCTL
          0     PAUSRT    (test if in PAUSRT)
          /4    1
          2     PAUSE
          7     LPCTL
          4     NXPORD+2  (resume after pause)
          5     NXPORD
          4     NXPORD+3
          5     NXPORD+1
          0     PAUSRT
          /8    1
PAUSE     8     STOP-1

LETD      4     +1
          5     DFLAG
          8     DUMP

PROMPT    \'^_            (prompt for control loop)
          \@

ENT8      4     ENTRYP    (load ALGOL intermediate code preserve
                            code procs and library)
          8     TOLOAD
ENT9      4     ENTRYP+1  (load, overwite code procs, preserve library)
          8     TOLOAD

ENT10     4     ENTRYP+2  (load, overwrite code proc and library)
TOLOAD    5     6         (set entry address - READAL etc and terminate
                            to level 4)
          4     +1        (set flag to indicate loading ALGOL)
          0     ENTRYP+3
          /5    0
          15    7168
          4     ENTRYP+4  (on level one interrupt go to LPCTL)
          5     6
          8     ;-3

ENTRYP    +READAL         (entry at  8 - read ALGOL program)
          +REDAL1         (entry at  9 - load overwriting code procs)
          +REDAL2         (entry at 10 - load overwriting code procs
                                                       + library)
          :ALGFLG
          +LPCTL

STKBAS    >1              ( base of stack after program)
STKMOD    :ENDLIB         (first free location after built-in library)
STKEND    +16383          (top of store)
WARNAD    :BEGLOA-6       (base of empty dictionary)
CODEPR    >1              (base of code procs in dictionary)
PDADD     >1              (LOADER dictionary entry for program)
STACKADD  >1
LAAD      +LA             (current load address in loader)

(code here to fill gap before BASE at 131)

(Hunter mod: new pord GETADD)
GETADD    11    FINDFP    (get address of call by name argument)
          8     FINDFP+1  (find argument on stack)
          0     W1
          /4    2         (word 2 = 0, i.e., no thunk)
          7     TFVR+3    (yes, treat as TFAI)
          8     BACK      (no, call thunk)

ADPORD    /4    2         (W1\2 < 0?) 
          9     FIN       (get result)
          1     =/0 0     (develop address)
          /5    2         (W1\2 +:= &800000)
          4     -1        (decrement PP to restart instruction)
          1     PP
STPP      5     PP        (PP -:= 1)
          0     SP
          4     +0        (SP\2 := 0)
          /5    2
          0     W1

BACK      4     SP        (scalars and formal functions)
          1     +3        (SP +:= 3 - space for result)
          5     SP
          /4    0         (W1\0 - address of thunk)
          8     CFF+2     (call thunk)

FIN       6     =15 8191  (restore parameter entry)
          /5    2         (W1\2 := W1\2 &3777777)
          4     SP        (overwrite address)
          1     -3
          5     SP        (SP -:= 3 - unstack)
          5     W1        (W1 := SP)
          0     W1
          8     TRCN+3    (join TRCN to decode parameter entry)

LLDR1A    +LLDR1
BLANKA    +BLANK          (reentry to loader)

RSTACK    >1
          0     W
          /4    0
          5     W3
          /4    1
          5     W4
          /4    2
          5     W5
          /4    3
          5     W6
          /4    4
          5     W7
          /4    5
          5     W8
          0     RSTACK
          /8    1

          >5

(BASE must be at 131 and layout from BASE to OUTSLT is interface for code 
procs)

BASE      +LIBRY          (131 - BASE - first location after LIBRARY)
          +8191           (132 - QACODL)
          +8191           (133 - QAVNDA)
WARN      +0              (134 - flags if loader etc overwritten)
PP        >1              (135 - pord pointer - next pord address)
SP        >1              (136 - stack pointer)
EP        >1              (137 - entry pointer)
FP        >1              (138 - formal pointer)
BN        >1              (139 - block number)
          0     PBA       (140-155 reserved for use by library)
          0     PRIM31    (R := R+R)
          0     PRIM33    (R := R-R)
          0     PRIM35    (R := R*R)
          0     PRIM37    (R := R/R)
          0     PRIM59    (entier)
          0     DLMULT    (double length multiplication)
          0     DLDIV     (double link divide)
          0     RRES      (store real result)
          0     SERIES    (sum series)
          0     STAND     (standardize real number)
          0     TABLE     (character code table)
          0     OTCHA     (output character)
          8     GECH      (get character)
          0     OSTSB     (output string)
          -1
STIM      -1              (156-165 library workspace)
          0     SBLNK1
          8     RICONV
          -1
          -1
          -1
          -1
          -1
          -1
PAUSRT    +STOP
          8     FAILEN    (166-177 for i/o library routines)
SBLNK2    >1
          +ODEV
          +GLOPMD
IOLNK     >1
          +OUTI
          +OUTR
NEXTCH    >1
          0     STSUBRT
OLDLBD    0     LPSYMS
          >4
W         +74             (180-223 interpreter workspace)
W1                        (can be used by user machine code)
TENPWR    >1
W2
NSIGNF    >1
FPA
W3        >1
W4        >1
W5        >1
FPB
W6        >1
W7
BEFPT     >1
W8
AFTPT     >1
W9
DECPWR    >1
WS        >1
WS1       >1
WS2       >1
WS3       >1
WS4       >1
WS5       >1
WS6       >1
WS7       >1
WS8       >1
ODEV
WS9       >1
DIGM
WS10      >1
DIGN
WS11      >1
OPMD
WS12      >1
PKDADD
WS13      >1
UNPACKED
WS14      >1
WS15      >1
WS16      >1
WS17      >1
WS18      >1
WS19      >1
WS20      >1
WS21      >1
WS22      >1
WS23      >1
WS24      >1
WS25      >1
WS26      >2
WS28      >1
WS29      >1
WS30      >2
WS32      >1
WS33      >1
SBW       >1
NXPDAD    +NXPORD
          >3
PCHLNK    >2              (used by I/O routines)
BUFFER    >10
INSLOT    >10
OUTSLT    +OUTPA+4        (1 ptr)
          +OUTPA+4
          +OUTPA+2        (3 tty)
          +OUTPA+4
          +OUTPA+4
          +OUTPA+4
          +OUTPA+4
          +OUTPA+4
          +OUTPA+4
          +OUTPA+4

T23LEN    -67             (length of ALGOL T23 Loader)

(This code is entered from the loader after reading in a
 call by name thunk.  Note original Hunter code had test
 for first pord of thunk to be a UJ and also checked for
 INDA or TRC -6 pords from final UJ, i.e., preceding ST
 RETURN sequence)

THUNK     0     LAAD
          /4    0         (next location to load)
          5     W+1       (LA)
          1     -8
          5     LOC       (start of thunk)
          0     LOC
          /4    6         (points to TA n)
          5     W
          1     STKMOD
          5     W+3
          0     W+3       (indirect through TA n to UJ)
          /4    0
          2     W
          1     =8 1
          7     ;+3
          4     +7        (first pord not UJ)
          8     FAIL
          4     STKMOD    (relativize LA)
          2     W+1
          1     =7 8191   (forms UJ to MKTHK at end of thunk)
          /5    0         (store forward jump at start of thunk)
          4     W
          1     =8 1
          0     LOC
          /5    6         (store backward jump at end of thunk)
          /4    1         (look for INDS before ST)
          6     =/15 0
          1     =5 0	  (test for INDS = /11 n)
          7     TINDS
	  1     =/6 0     (test for INDFS = 5 n)
          7     TINDFS
	  0     BLANKA
          /8    0
TINDS	  /4    1         (INDS to GTF)
          1     =14 0
          /5    1
          8     ;-5
TINDFS    /4    1	  (INDFS to GTFS)
	  1     =9 0
          /5    1
          8     ;-9

SINGLE    >1
          0     W
          /4    0
          5     W3
          /4    1
          5     W4
          /4    2
          5     W5
          0     SINGLE
          /8    1

RRES      >1
          0     W
          4     W3
          /5    0
          4     W4
          /5    1
          4     W5
          /5    2
          0     RRES
          /8    1

FAIL      >1
          11    PAUSRT
          8     FAILEN
          4     W3
          9     ;+9
          4     =15 8191
          5     W3
          4     &377600
          5     W4
          4     +63
          5     W5
          0     FAIL
          /8    1
          4     =/0 0
          5     W3
          4     +0
          8     ;-8

PRIM30    >1              (I:=I+I)
          0     W
          /4    0
          9     ;+8
          /4    3
          9     ;+8
          /1    0
          9     ;+10
          /5    0
          0     PRIM30
          /8    1
          /4    3
          9     ;+3
          /1    0
          8     ;-6
          /1    0
          9     ;-8
          8     INTOVR

PRIM32    >1              (I:=I-I)
          0     W
          /4    3
          2     +0
          /5    3
          1     =/0 0
          7     ;+4
          4     PRIM32
          5     PRIM30
          8     PRIM30+2
          /4    0
          9     ;+2
          8     PRIM30+17
          /1    3
          /5    0
          0     PRIM32
          /8    1

PRIM34    >1              (I:=I*I)
          0     W
          /4    0
          /12   3
          3     WS1
          7     ;+4
          1     +1
          7     ;+6
          8     PRIM30+17
          4     WS1
          /5    0
          0     PRIM34
          /8    1
          4     WS1
          1     =/0 0
          8     ;-5

PRIM38    >1              (I:=I^I)
          0     W
          /4    0
          7     ;+23
          5     WS1
          /4    3
          9     SPARE
          7     ;+21
          2     +0
          5     COUNT
CALC      10    COUNT
          4     COUNT
          7     ;+12
          4     WS1
          /12   0
          3     WS1
          7     CALC
          1     +1
          7     ;+2
          8     INTOVR
          4     WS1
          1     =/0 0
          5     WS1
          8     CALC
          4     WS1
          /5    0
          0     PRIM38
          /8    1
          4     +1
          8     ;-4

(New code for relational operators and sign from Terry Froggatt)
SET       >1
NEGTRU    9     SETTRU
SETFLS    4     +0
          8     ;+3
NEGFLS    9     SETFLS
SETTRU    4     +1
          0     W
          /5    0
SETEX     0     SET
          /8    1

PRIM41    >1              (B := I < I)
          4     ;-1
          5     SET
          0     W
          /4    0
          9     ;+5
          /4    3
          9     SETFLS
          /2    0
          8     NEGTRU
          /4    3
          9     ;-3
          8     SETTRU

PRIM43    >1              (B := I le I)
          4     ;-1
          5     SET
          0     W
          /4    3
          9     ;+5
          /4    0
          9     SETTRU
          /2    3
          8     NEGFLS
          /4    0
          9     ;-3
          8     SETFLS

PRIM45    >1              (B := I = I)
          4     ;-1
          5     SET
          0     W
          /4    0
          /2    3
ZERTRU    7     SETTRU
          8     SETFLS

PRIM47    >1              (B := I ne I)
          4     ;-1
          5     SET
          0     W
          /4    0
          /2    3
ZERFLS    7     SETFLS
          8     SETTRU

PRIM49    >1              (B := I > I)
          4     ;-1
          5     SET
          0     W
          /4    3
          9     ;+5
          /4    0
          9     SETFLS
          /2    3
          8     NEGTRU
          /4    0
          9     ;-3
          8     SETTRU

PRIM51    >1              (B := I ge I)
          4     ;-1
          5     SET
          0     W
          /4    0
          9     ;+5
          /4    3
          9     SETTRU
          /2    0
          8     NEGFLS
          /4    3
          9     ;-3
          8     SETFLS

SETSET    5     SET
          8     PRIM33+1

PRIM42    >1              (B := R < R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          8     NEGTRU

PRIM44    >1              (B := R le R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          7     SETTRU
          8     NEGTRU

PRIM46    >1              (B := R = R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          8     ZERTRU

PRIM48    >1              (B := R ne R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          8     ZERFLS

PRIM50    >1              (B := R > R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          7     SETFLS
          8     NEGFLS

PRIM52    >1              (B := R ge R)
          4     ;-1
          11    PRIM33
          8     SETSET
          4     W3
          8     NEGFLS

PRIM53    >1              (B := B and B)
          4     ;-1
          5     SET
          0     W
          /4    3
          7     SETFLS
          8     SETEX

PRIM54    >1              (B := B or B)
          4     ;-1
          5     SET
          0     W
          /4    3
          7     SETEX
          8     SETTRU

PRIM55    >1              (B := B equiv B)
          4     ;-1
          5     SET
          0     W
          /4    3
          7     TOGGLE
          8     SETEX

PRIM56    >1              (B := B impl B)
          4     ;-1
          5     SET
          0     W
          /4    0
          7     SETTRU
          /4    3
          8     ZERFLS

PRIM57    >1              (B := not B)
          4     ;-1
          5     SET
          0     W
TOGGLE    /4    0
          8     ZERTRU

PRIM62    >1              (sign)
          0     W
          /4    0
          7     ;+6
          9     ;+3
          4     +1
          8     ;+2
          4     -1
          /5    0
          0     PRIM62
          /8    1

SBLNK
STAND     >1
          4     +0
          5     SBW
          4     W3
          7     STAND3
          9     STAND4
STAND1    14    1
          9     STAND2
          10    SBW
          8     STAND1
STAND7    4     +0
          5     W3
          5     W4
STAND5    5     W5
          8     STAND6
STAND3    4     +17
          5     SBW
          4     W4
          7     STAND5
          8     STAND1
STAND4    1     +1
          7     ;+3
          4     W3
          8     ;+5
          4     +16
          5     SBW
          4     W4
          10    SBW
          14    1
          9     ;-2
STAND2    4     SBW
SHIFTD    5     SBW
          2     W5
          5     W5
          1     +64
          9     STAND7
          1     -128
          9     ;+5
          4     STAND
          5     FAIL
          4     +9
          8     FAIL+1
          4     SBW
          7     STAND6
          6     +8191
          1     SHFT1
          5     SHIFTN
          0     W4
          14    1
          4     W3
SHIFTN    14    3
          3     W4
          5     W3
STAND6    0     STAND
          /8    1

SHFT1     14    0

SHIFT1    >1
          0     W4
          14    1
          4     W3
          14    8191
          5     W3
          3     W4
          0     W7
          14    1
          4     W6
          14    8191
          5     W6
          3     W7
          10    W5
          10    W8
          0     SHIFT1
          /8    1

PRIM31    >1              (R := R+R)
          11    RSTACK
          8     RSTACK+1
          4     W3
          7     EXTRAT
          4     W6
          7     EXIT31+2
          11    SHIFT1
          8     SHIFT1+1
          4     W5
          2     W8
          9     NEG5
          2     +0
          1     =15 0
          6     =14 8191
          5     ;+6
          4     W8
          5     W5
          0     W4
          14    1
          4     W3
          +0
          3     W4
          1     W6
          5     W3
          4     W4
          1     W7
          9     ;+8
          5     W4
EXIT31    11    STAND
          8     STAND+1
          11    RRES
          8     RRES+1
          0     PRIM31
          /8    1
          6     =15 8191
          10    W3
          8     ;-9
NEG5      6     =14 8191
          5     ;+4
          0     W7
          14    1
          4     W6
          +0
          3     W7
          1     W3
          5     W3
          4     W7
          1     W4
          9     ;+2
          8     EXIT31-1
          10    W3
          6     =15 8191
          8     EXIT31-1
EXTRAT    4     W6
          5     W3
          4     W7
          5     W4
          4     W8
          5     W5
          8     EXIT31

PRIM33    >1              (R:=R-R)
          11    RSTACK
          8     RSTACK+1
          4     W6
          9     ;+16
          4     W7
          7     ;+11
          2     +0
          6     =15 8191
          5     W7
          4     W6
          2     +0
          1     =/15 8191
          5     W6
          4     PRIM33
          5     PRIM31
          8     PRIM31+3
          4     W6
          2     +0
          8     ;-6
          1     =/0 0
          7     ;+2
          8     ;-17
          4     W7
          7     ;+2
          8     ;-18
          4     =8 0
          10    W8
          8     ;-15
DLMULT    +0
          4     W6
          12    W3
          5     WS10
          3     WS11
          4     W7
          12    W3
          14    8175
          3     WS12
          1     WS10
          5     W3
          4     WS11
          1     WS12
          9     ;+19
          5     WS11
          4     W6
          12    W4
          14    8175
          3     WS12
          1     W3
          5     W3
          4     WS12
          1     WS11
          9     ;+6
          5     W4
          7     ;+10
          4     W3
          0     DLMULT
          /8    1
          6     =15 8191
          10    W3
          8     ;-7
          6     =15 8191
          10    W3
          8     DLMULT+14
          4     W3
          1     =/0 0
          7     ;+2
          8     ;-12
          4     =15 8191
          5     W3
          5     W4
          8     ;-15

PRIM35    >1              (R:=R*R)
          11    RSTACK
          8     RSTACK+1
          4     W5
          1     W8
          5     W5
          11    DLMULT
          8     DLMULT+1
          11    STAND
          8     STAND+1
          11    RRES
          8     RRES+1
          0     PRIM35
          /8    1

PRIM37    >1              (R:=R/R)
          11    RSTACK
          8     RSTACK+1
          0     W4
          14    1
          4     W3
          14    8191
          3     W4
          5     W3
          7     ;+16
          10    W5
          4     W6
          7     ;+15
          5     WS17
          4     W7
          5     WS18
          11    DLDIV
          8     DLDIV+1
          4     W8
          2     W5
          5     W5
          11    STAND
          8     STAND+1
EXIT37    11    RRES
          8     RRES+1
          0     PRIM37
          /8    1
          4     +9
          11    FAIL
          8     FAIL+1
          8     EXIT37


ITOR      >1              (integer to real conversion)
          0     W
          /4    3
          5     W3
          4     +0
          5     W4
          4     +17
          5     W5
          11    STAND
          8     STAND+1
          4     W3
          5     W6
          4     W4
          5     W7
          4     W5
          5     W8
          0     W
          /4    0
          5     W3
          4     +0
          5     W4
          4     +17
          5     W5
          11    STAND
          8     STAND+1
          11    RRES
          8     RRES+1
          0     ITOR
          /8    1

PRIM40    >1              (R:=R^R)
          11    RSTACK
          8     RSTACK+1
          4     W3
          9     ;+23
          7     ;+20
          4     W6
          7     ;+28
          5     WS5
          4     W7
          5     WS6
          4     W8
          5     WS7
          11    PRIM61
          8     PRIM61+3
          4     WS5
          5     W6
          4     WS6
          5     W7
          4     WS7
          5     W8
          11    PRIM35
          8     PRIM35+3
          11    EXP
          8     EXP+3
          0     PRIM40
          /8    1
          4     +19
          11    PAUSRT
          8     FAILEN
          4     +0
          5     W3
          5     W4
          5     W5
          8     ;+7
          4     =8 0
          5     W3
          4     +0
          5     W4
          4     +1
          5     W5
          11    RRES
          8     RRES+1
          8     ;-18

PRIM36    >1              (R:=I/I)
          11    ITOR
          8     ITOR+1
          11    PRIM37
          8     PRIM37+3
          0     PRIM36
          /8    1

PRIM39    >1              (R:=I^I)
          0     W
          /4    0
          7     EXTRA2+5
          /4    3
          9     EXTRA2
          7     EXTRA2+11
          2     +0
          5     WS5
          4     +0
          5     MKR7
          5     W4
          /4    0
          5     W3
          4     +17
          5     W5
          11    STAND
          8     STAND+1
          4     W3
          5     W6
          4     W4
          5     W7
          4     W5
          5     W8
          10    WS5
          4     WS5
          9     ;+2
          8     ;+4
          11    PRIM35
          8     PRIM35+3
          8     ;-6
          4     MKR7
          9     ;+4
          8     EXTRA2+8
EXIT39    0     PRIM39
          /8    1
          4     W3
          5     W6
          4     W4
          5     W7
          4     W5
          5     W8
          4     =8 0
          5     W3
          4     +0
          5     W4
          4     +1
          5     W5
          11    PRIM37
          8     PRIM37+3
          8     ;-16
EXTRA2    5     WS5
          4     =/0 0
          5     MKR7
          4     +0
          8     PRIM39+11
          5     W3
          5     W5
          5     W4
          11    RRES
          8     RRES+1
          8     EXIT39
          4     =8 0
          5     W3
          4     +1
          5     W5
          4     +0
          8     ;-9

PRIM59    >1              (entier)
          0     W
          /4    2
          9     EXIT59+2
          7     EXIT59+2
          2     +17
          9     PRIM30+17
          7     ;+7
          2     +0
          6     =14 8191
          5     ;+2
          /4    0
          +0
          /5    0
EXIT59    0     PRIM59
          /8    1
          /4    0
          9     ;+3
          4     +0
          8     ;-6
          4     -1
          8     ;-8

PRIM58    >1              (abs)
          0     W
          /4    0
          9     ;+3
EXIT58    0     PRIM58
          /8    1
          1     =/0 0
          7     ;+15
          /4    0
          2     +0
          /5    0
          /4    1
          2     +0
          9     ;+3
          /5    1
          8     EXIT58
          6     =15 8191
          /5    1
          /4    0
          1     =/15 8191
          /5    0
          8     EXIT58
          /4    1
          7     ;+2
          8     EXIT58+4
          /10   2
          4     =8 0
          8     ;-7

(New integer divide code from Terry Froggatt)
DIV       4     SP
          1     -3
          5     SP
          1     -3
          5     W

          0     W
          /4    3
          5     WS1
          9     DENNEG

          7     INTOVR
          1     -1
          7     NXPORD
          /4    0
          9     SHIFTR-2
          8     SHIFTR

DENNEG    1     +1
          7     NEGATE
          /4    0
          9     ;+2
          8     SHIFTR-1
          1     -1
          9     SHIFTR

          2     -1
          4     -3
          13    WS1
          14    8191
          6     &377777
          8     EXIT

NEGATE    /4    0
          2     &400000
          7     INTOVR
          1     &400000
          8     EXIT

(-2)      1     -1
(-1)      1     WS1
SHIFTR    14    8176
          13    WS1
          14    8191
EXIT      /5    0
          8     NXPORD

PRIM28    4     EXIT28+1  (R:=R^I)
          5     PRIM39
          4     SP
          1     -6
          5     W
          1     +3
          5     SP
          11    SINGLE
          8     SINGLE+1
          0     W
          /4    0
          7     EXTRA2+5
          /4    3
          7     EXTRA2+11
          9     ;+6
          2     +0
          5     WS5
          4     +0
          5     MKR7
          8     PRIM39+18
          5     WS5
          4     =/0 0
          5     MKR7
EXIT28    8     PRIM39+18
          0     NXPORD-1

PRIM61    >1              (ln)
          11    SINGLE
          8     SINGLE+1
          4     FPA
          7     LOERR
          9     LOERR
          0     FPA+1
          14    1
          4     FPA
          14    8191
          1     =8 0
          5     WS+17
          3     WS+18
          1     =/0 0
          5     FPA
          3     FPA+1
          11    DLDIV
          8     DLDIV+1
          5     FPB
          4     FPA+1
          5     FPB+1
          11    DLMULT
          8     DLMULT+1
          5     FPB
          4     FPA+1
          5     FPB+1
          11    SERIES
          8     SERIES+1
          +18142
          +75061
          +20153
          +80261
          +23831
          +48226
          +29127
          +14509
          +37449
          +18724
          +52428
          +104857
          +87381
          +43690
          +0
          -1
          11    DLMULT
          8     DLMULT+1
          0     WS+29
          14    1
          4     WS+28
          3     FPB+1
          5     FPB
          14    1
          5     WS+28
          3     WS+29
          11    DLMULT
          8     DLMULT+1
          1     WS+28
          5     FPA
          4     FPA+1
          1     WS+29
          9     LOV
LO        5     FPA+1
          4     FPA+2
          5     LOK
          4     +0
          5     FPA+2
          11    STAND
          8     STAND+1
          4     FPA
          5     WS+28
          4     FPA+1
          5     WS+29
          4     FPA+2
          5     WS+30
          4     LOK
          11    SBLNK
          8     ITRSB1
          4     LOGE2
          5     W6
          4     LOGE2+1
          5     W7
          11    DLMULT
          8     DLMULT+1
          11    STAND
          8     STAND+1
          4     WS+28
          5     W6
          4     WS+29
          5     W7
          4     WS+30
          5     W8
          11    PRIM31
          8     PRIM31+3
LGEX      0     PRIM61
          /8    1
LOGE2     +90852
          +24543

LOV       6     +131071
          10    FPA
          8     LO
LOERR     4     +13
          11    PAUSRT
          8     FAILEN
          4     +0
          0     W
          /5    0
          /5    1
          /5    2
          8     LGEX
LOK       >1

EXP       >1              (exp)
          11    SINGLE
          8     SINGLE+1
          4     FPA+2
          9     EXNEGP
          1     -17
          9     EXPOSP
          4     FPA
          9     EXZERO
          4     +12
          11    FAIL
          8     FAIL+1
          8     EXPEXIT
EXZERO    4     +0
          5     FPA
          5     FPA+1
          5     FPA+2
          8     EXPEXIT
EXONE     4     -36
EXNEGP    1     +36
          9     EXONE
          1     =14 8156
          5     ;+4
          0     FPA+1
          14    1
          4     FPA
          +0
          5     FPA
          3     FPA+1
          4     +0
          5     FPA+2
EXPOSP    4     FPA+2
          1     =14 1
          5     ;+16
          1     =0 8175
          6     =14 8191
          5     ;+7
          4     LOG2E+1
          5     FPB+1
          4     LOG2E
          5     FPB
          11    DLMULT
          8     DLMULT+1
          +0
          5     FPA+2
          10    FPA+2
          0     FPA+1
          14    1
          4     FPA
          +0
          6     =15 8191
          1     =/8 0
          14    1
          5     FPB
          3     FPB+1
          11    SERIES
          8     SERIES+1
          +0
          +1453
          +0
          +29363
          +3
          +112955
          +55
          +93527
          +643
          +3708
          +5566
          +21285
          +32121
          +12955
          +92681
          +117968
          +0
          -1
          11    STAND
          8     STAND+1
EXPEXIT   11    RRES
          8     RRES+1
          0     EXP
          /8    1
LOG2E     +94548
          +60581

BUFLAG    >1
HALTMK    >1
W10
SIGNCH    >1
ADPART    >1
W3ADDR    :W3
SBLNK1    >1
SUBWK1    >1
SBW1      >1
SBW2      >1
SBW3      >1
SBW4      >1
SBW5      >1
SW        >1
SW1       >1

PBA       0     0
          0     CBL
          0     CHECKB
          0     CHECKI
          0     CHECKR
          0     CHECKS
          0     DO
          0     STW
          0     FINISH
          0     FOR
          0     FR
          0     FSE
          0     DIV
          0     ITOR1
          0     ITOR2
          0     NEGI
          0     NEGR
          0     RETURN
          0     RTOI1
          0     SPARE
          0     ST
          0     STA
          0     STEP
          0     ST
          0     WAIT
          0     STEP2     (Hunter mod: was 0 STEP)
          0     UNTIL
          0     UP
          0     PRIM28
          0     WHILE
          0     PRIM30
          0     PRIM31
          0     PRIM32
          0     PRIM33
          0     PRIM34
          0     PRIM35
          0     PRIM36
          0     PRIM37
          0     PRIM38
          0     PRIM39
          0     PRIM40
          0     PRIM41
          0     PRIM42
          0     PRIM43
          0     PRIM44
          0     PRIM45
          0     PRIM46
          0     PRIM47
          0     PRIM48
          0     PRIM49
          0     PRIM50
          0     PRIM51
          0     PRIM52
          0     PRIM53
          0     PRIM54
          0     PRIM55
          0     PRIM56
          0     PRIM57
          0     PRIM58    (abs)
          0     PRIM59    (entier)
          0     EXP
          0     PRIM61    (ln)
          0     PRIM62    (sign)
          0     PRIM63    (constant 3 [n-60])
          0     PRIM63    (constant 4 etc)
          0     PRIM63
          0     PRIM63
          0     PRIM63
          0     PRIM63
          0     PRIM63
          0     PRIM63

FLNST1    >2
FAILHD    0     ;+1
          &070101
          \ERR
          \OR
          \NO
          \ AD
          \R
          \RET
          &014000

FAILEN    14    8175
          4     W3
          5     WS
          3     W3
          4     -4096
          15    6144
          1     +256
          9     ;-2
          4     +3
          5     ODEV
          4     FAILHD
          11    SBLNK2
          8     OSTSB
          4     PRFA1
          5     FLNST1
          4     NULSTR+2
          5     PRFA1
          4     IOLNK
          5     FLNST1+1
          4     +6
          11    IOLNK
          8     OUTI5
          4     STKMOD    (16KLP mod: was 4 PDADD)
          2     PP
          5     W3
          4     +5
          11    IOLNK
          8     OUTI5
          0     EP
          4     EP
          2     STKBASE   (16KLP mod: was 2 STACKADD)
          7     ;+3
          4     STKMOD    (16KLP mod: was 4 PDADD)
          /2    1
          5     W3
          4     +5
          11    IOLNK
          8     OUTI5
          4     FLNST1
          5     PRFA1
          4     +1
          11    OTCHA
          8     OTCHA1
          4     WS
          5     W3
          4     FLNST1+1
          5     IOLNK
          8     LPCTL

WAIT      11    PAUSRT
          8     LPCTL
          8     NXPORD

FAILNS    +2
FLNS1     +3
FLNS2     +4
FLNS3     +5
FLNS4     +9
FLNS5     +1
FLNS6     +7
FLNS7     +6
FLNS14    +15
FLNS15    +14
FLNS16    +16
FLNS17    +18
FLNS19    +8
FLNS21    +22
FLNS22    +20

GTSFAIL   4     FLNS2
ENFAIL    11    PAUSRT
          8     FAILEN
          8     STOP-1
(+3)      4     +21
          8     ENFAIL

STSUBRT   >1              (standardize, pack and store)
          4     SP        (stack has: value, address)
          1     -6
          5     PKDADD    (W, PKDADD := SP-6)
          5     W
          1     +3
          5     SP        (SBW, SP := W-3)
          5     SBW
          0     SBW
          /4    0
          5     W3        (W3,4,5 := value)
          /4    1
          5     W4
          /4    2
          5     W5
STSUB     0     PKDADD
          /4    0         (PKDADD = address)
          5     PKDADD
          6     =/8 0
          7     STSUB1    (address bits 18-17 = 00?)
          14    1
          9     ENFAIL+3  (Error 21: bit 17=1 => constant formal parameter)
          /4    1
          9     STSUB7    (PKDADD\1 < 0 => packed)
          4     W4
          1     +64
          9     STSUB2    (W4<-64?)
          6     &377600   (W4>=-64)
          5     W4        (W4 &:= not 64)
STSUB3    4     W5
          1     +64
          9     STSUB5    (W5<-64?)
          1     -128
          9     ;+4       (W5<64?)
          4     FLNS4     (no - switch jump error)
          11    FAIL
          8     FAIL+1
          4     W5
          6     +127
          1     W4
          0     PKDADD
          /5    1         (address\1 := W5 & +127 + W4)
STSUB1    0     PKDADD    (00: \address := value)
          4     W3
          /5    0
          0     STSUBRT   (exit)
          /8    1

STSUB7    4     W5        (W4<-64)
          0     PKDADD
          /5    2         (address\2 := W5)
          4     W4        (address\1 := W4)
          8     STSUB1-1

STSUB5    4     +0        (W5<-64)
          5     W3
          5     W5        (W3,4,5 := 0)
          8     STSUB3-1

STSUB2    4     +0        (W4<-64)
          5     W4        (W4 := 0)
          10    W3        (W3 +:= 1 & =7 8191)
          4     W3
          6     =7 8191
          11    SBLNK
          7     ;+2
          8     STSUB3
          4     W3
          14    1
          0     W3ADDR
          9     NEGR4+7   (W3 bit 17=1?)
          8     NEGR3

W345R     4     SP
          1     -3
W345R1    5     W
          0     W
W345R2    /4    0
          5     W3
          /4    1
          5     W4
          /4    2
          5     W5
          0     SBLNK
          /8    1

RICONV    4     W5
          1     -17
          9     RICON1
          7     RICON2
NEGIE
INTOVR    4     FLNS1
          8     ENFAIL
RICON1    11    SBLNK
          8     SHIFTD
RICON2    4     =8 0
          2     W4
          9     RICON3
          4     W3
          9     RICON4
          1     +1
          9     INTOVR
          8     ;+2
RICON4    1     +1
          5     W3
RICON3    4     W3
          0     SBLNK1
          /8    1
ITRSB1    5     W3
ITRSB2    4     +0
          5     W4
          4     +17
          5     W5
          8     STAND+1
NEGR1     0     W
NEGR6     /4    1
          7     NEGR4
          2     +0
          6     =15 8191
          /5    1
          /10   0
NEGR5     /4    0
          2     +0
NEGR2     /5    0
          0     SBLNK
          /8    1
NEGR4     /4    0
          2     =/0 0
          7     NEGR3
          /4    0
          2     =8 0
          7     ;+2
          8     NEGR5
          /4    2
          1     -1
          /5    2
          4     =/0 0
          8     NEGR2
NEGR3     /10   2
          4     =8 0
          8     NEGR2

GLOPMD    >1              (n.b. Loader relies on)
GLIDEV    >1              (this block of work spaces)
GLODEV    >1              (and references them relative)
GLPRFA    >1              (to GLOPMD)
GLINTD    >1
GLDIGM    >1
GLDIGN    >1
OPMD1     >1
IDEV      +1
ODEV1     +1
PRFA1     >1
INTDG     +4
DIGM1     +2
DIGN1     +8

RELOAD    0     WARN      (determine if reloads needed)
          /4    RELTAB
          0     +6
          3     ODEV
          11    SBLNK2
          8     OSTSB
          4     +0        (clear warning)
          5     WARN
          8     STOP-1
RELTAB    0     NOPROG
          0     NOPROC
          0     NOLIB
          0     NOSYS
NOPROG    &070101
          \NO
          \PRO
          \GRA
          &550140
NOPROC    &070162
          \ELO
          \AD
          \MAC
          \HIN
          \E C
          \ODE
          &014000
NOLIB     &070162
          \ELO
          \AD
          \LIB
          \RAR
          &710140
NOSYS     &070162
          \ELO
          \AD
          \SYS
          \TEM
          &014000

READAL    4     WARN      (entry to read ALGOL)
          7     ;+2
          8     RELOAD
          4     +1
          0     +BEGLOA/
          /8    BEGLOA+1

REDAL1    4     WARN      (entry to read ALGOL overwriting code procs)
          2     +1
          9     RELOAD
          4     +2
          0     +BEGLOA/
          /8    BEGLOA+1

REDAL2    4     WARN      (entry to read ALGOL overwriting procs and library)
          2     +3
          7     RELOAD
          4     +3
          0     +BEGLOA/
          /8    BEGLOA+1

ENT11     4     WARN      (entry to load additional code procedure)
          7     ;+2
          8     RELOAD
          4     +4
          0     +BEGLOA/
          /8    BEGLOA+1

ENT12     4     WARN      (entry to load additional code procedure)
          2     +1        (replacing all others                   )
          9     RELOAD
          4     +5
          0     +BEGLOA/
          /8    BEGLOA+1

ENT13     4     WARN      (entry to load new library replacing previous)
          2     +3        (library and previously loaded procedures)
          7     RELOAD
          4     +6
          0     +BEGLOA/
          /8    BEGLOA+1

RUNALG    4     BASE+2    (run ALGOL)
          2     +8191
          7     RELOAD
          4     STKBASE
          5     SP
          5     EP
          4     STKMOD
          5     PP
          0     PP
          /4    8
          2     &010140   (resume original code)
          7     ;+3
          4     +25
          8     ENFAIL
          4     -1
          5     BUFLAG
          4     +1
          5     GLIDEV
          5     GLODEV
          4     -10
          5     W
          0     W
          4     +0
          /5    BUFFER+10
          4     INPA
          /5    INSLOT+10 (default input devices to ptr)
          4     OUTPA
          /5    OUTSLT+10 (default output devices to ptr)
          10    W
          4     W
          9     ;-9
          4     OUTPA+1   (new code)
          5     OUTSLT+2  (output device 3 = tty)
          4     INPA+1
          5     INSLOT+2  (input  device 3 = tty)
          4     +6
          5     GLINTD
          4     +7
          5     GLDIGN
          4     NULSTR+3
          5     GLPRFA
          4     +0
          5     GLOPMD
          4     +800
          5     BN
          0     NXPDAD
          /8    0

PRIM      0     ADPART    (PRIM operation)
          1     -30
          /0    PBA
          /9    0         (ADPART<30 - jump through table)
          1     -27
          9     PRIMA     (31<ADPART<57 - subroutine, W := SP-6)
          4     SP        (ADPART>57 - subroutine, W := SP-3)
          1     -3
          5     W
          8     PRIMA1

PRIMA     4     SP
          1     -6
          5     W
          1     +3
          5     SP
PRIMA1    /11   0
          /8    1

NXPORD    8     NXPORD+4
          8     NXPORD+1
          8     NXPORD+4
          8     NXPORD+1
          0     PP        (advance PP)
          /4    0
          10    PP
          14    8179
          5     W         (opcode to W)
          /4    0
          6     +8191
          5     ADPART    (address to ADPART)
          0     W
          /8    FBAJ      (branch of FBAJ table)
          8     MKTHK     (make thunk)
          8     TICA      (take integer constant address)
          8     TIC       (take integer constant)
          8     TRCA      (take real constant address)
          8     TRC       (take real constant)
          8     CF        (call function)
          8     CFF       (call formal function)
          8     PE        (procedure/block entry)
          8     TFAI      (take formal argument integer)
          8     GETADD    (get address of call by name argument)
          8     TRCN      (get value of call by name argument)
          8     INDS      (index switch)
          8     IFUN      (integer formal name)
          8     RFUN      (real formal name)
          8     CFSIR     (call code procedure / enter machine code)
          8     PRIM      (primitive)
FBAJ      8     TANEW     (take address)
          8     TIA       (take integer address)
          8     TIR       (take integer result)
          8     TRA       (take real address)
          8     TRR       (take real result)
          8     INDFS     (index formal switch)
          8     MAMPS     (make array)
          8     IFJ       (if jump)
          8     UJ        (unconditional jump)
          8     GTS       (go to switch)
          8     GT        (go to label)
          8     GTF       (go to formal label)
          8     INDA      (index address)
          8     INDR      (index result)
          8     GTFS      (go to formal switch)
          8     INOUT     (i/o)

(AJH modified FINDFP based on Hunter FINDFP)
FINDFP    >1              (find formal parameter)
          4     ADPART    (block number and parameter number)
          6     +15
          5     W         (argument number)
          2     ADPART
          5     SUBWK1+1  (block number)
          2     BN
          7     FINDP3    (found in top entry)
          0     EP
FINDP1    /4    2         (is current entry a loop?)
          9     FNDEP     (yes - need to skip over it)
          /4    0         (is EP' = ENV'?)
          /2    4
          7     FNDEP     (yes - retreat via EP)
FNDENV    /4    4         (no - find frame ENV')
          5     LOC
FNDELP    2     STKBASE   (check not at end of stack)
          9     ;+2
          8     SPARE
          /0    0         (go back an entry)
          /4    0         (EP' of previous entry)
          2     LOC       (equals our target?)
          7     FNDEVB    (yes, resume check for block)
          /4    0         (no, continue down EP chain)
          8     FNDELP    (keeping looking)
FNDEVB    /4    3
          2     SUBWK1+1
          7     FINDP4
          8     FINDP1    (block doesn't match)

FNDEP     /4    3         (BN' = block?)
          2     SUBWK1+1
          7     FINDP4    (yes - next entry matches)
          /4    0         (check not at end of stack)
          2     STKBASE
          9     FNDSOK    (ok to continue)

SPARE     4     +20       (corrupt program, e.g., bogus opcode,
                                                       broken stack etc)
          8     ENFAIL
          8     SPARE

FNDSOK    /0    0         (move down stack via EP')
          8     FINDP1

FINDP3    0     EP
          /4    2         (previous SP)
          1     -3        (result)
          1     W
          1     W
          1     W
          5     W1        (W1 := address of argument slot on stack)
          0     W1
          /4    0         (fetch address field from slot)
          0     FINDFP
          /8    1

FINDP4    /0    0         (formal found in previous entry)
          8     FINDP3+1

(-1)      1     +32       (for entry via CFSIR)
PEM       5     W         (procedure entry - machine code)
          1     W         (set up block frame to enable return)
          1     W
          2     EP        (SP[0] := EP - 3 * number of args)
          0     SP
          /5    0
          1     -3
          5     FP        (FP := SP[0] - 3)
          4     BN
          /5    1         (SP[1] := BN)
          10    SP
          10    SP        (SP +: 2)
          0     PP
          /11   0         (enter machine code)
          /8    1

RETURN    0     EP        (return from procedure / block)
          /4    3
          5     BN        (BN := BN')
          /4    2
          5     SP        (SP := SP')
          /4    1
          5     PP        (PP := PP')
          /4    0
          5     EP        (EP := EP')
          8     NXPORD

(Hunter modifications for TA)
TABAK     /4    0         (go to previous entry)
          2     STKBAS    (bottom of stack?)
          7     TASAVE    (cannot be a formal parameter)
          /0    0
          8     TATST

TANEW     1     STKMOD    (Take Address)
          5     ADPART
          0     EP        (Calculate current environment)
TATST     14    1
          3     LOC       (LOC := EP)
          /4    2
          9     TABAK     (EP[2] < 0 => FOR entry, need to go back further)
TASAVE    4     LOC       (SP\2 := LOC)
          0     SP
          /5    2
          4     ADPART
          8     TA2       (rejoin original TA to store result)


TIA       1     BASE+2    (take integer address)
          5     W1        (W1 := address+QAVNDA)
          4     +1
          8     TACHK     (SP\1 := +1)

(AJH modification - TA global identifier)
TASIR     2     -1        (take address code procedure - via INOUT)
          1     BASE
          5     ADPART    (absolute address)
          8     TANEW+2

TRA       1     BASE+2    (take real address)
          1     =/0 0
TRAP3     5     W1
          4     +2
TACHK     0     SP
          /5    1         (SP\1 := ...)
CLEAR     4     +0
CLEAR1    /5    2         (SP\2 := 0)
          4     W1        (SP\0 := W1)
TA1       0     SP
TA2       /5    0
UP        4     SP        (SP := SP+3)
          1     +3
          5     SP
          2     STKEND
          9     MAMPS5
          8     NXPORD

(Hunter modification)
(Call by name handling - set up address of thunk on stack)
MKTHK     0     SP
          4     PP
          1     -4
          /5    0         (SP\0 := PP-4 - PE in thunk)
          4     +7
          2     PP
          5     LOC       (LOC := PP-7)
TESTIT    4     ADPART
          2     +9
          7     TI1       (skip to TI1 if MKTHK 9 [label] - type 9)
          0     LOC
          /4    0         (test if PP-7 is INDA - 1 or 2)
          6     =/15 0
          2     =12 0
          7     ;+2
          4     +4        (PP-7 not INDA - type 4 or 5)
TI1       0     SP        (build an address slot)
          1     ADPART
          /5    1         (SP\1 set type field to 1/2, 5/6 or 9)
          4     EP
          /5    2         (SP\2 := EP)
          8     UP        (advance SP)

TRR       1     BASE+2    (take real result - W := address+QAVNDA)
STKRLV    5     W+1       (unpack and stack real value)
          0     W+1
          /4    1
          5     W+2
          /4    0
          0     SP
          /5    0
          4     W+2
          6     &777600
          /5    1
          4     W+2
          14    11
          14    8181
          /5    2
          8     UP

TIR       1     BASE+2    (take integer result - load integer onto stack)
          5     W
          0     W         (fetch integer from QAVNDA)
          /4    0
          8     TA1       (Hunter mod: was 8 TA)

TRCA      1     BASE+1    (take real constant address)
          1     =/8 0     (address + bit18)
          8     TRAP3

TICA      1     BASE+1    (take integer constant address)
          1     =8 0      (form QACODL+address+=8 0)
          8     TIA+1

RFUN      11    FINDFP    (take address of real formal parameter)
          8     FINDFP+1
          4     W1
          1     =/0 0
          5     W1
          4     =/0 2
          8     TACHK

IFUN      11    FINDFP    (take address of integer formal argument)
          8     FINDFP+1
          8     TIA+2

TIC       1     BASE+1    (take integer constant - W := address+QACODL)
          8     TIR+1

TRC       1     BASE+1    (take real constant  - W := address+QACODL)
          8     STKRLV

IFJ       4     +3        (if jump)
          2     SP
          5     SP        (SP-:= 3)
          0     SP
          /4    0         (SP\0 = 0?)
          7     ;+2
          8     NXPORD
          4     ADPART    (construct address for skipping over THEN clause)

UJ        1     STKMOD    (unconditional jump)
          5     PP        (store absolute address in PP)
          8     NXPORD

PE        6     +15       (procedure / block entry)
          5     W         (number of parameters)
          1     W
          1     W         (size of parameters in words)
          2     EP        (start of stack frame)
          0     SP
          /5    0         (W4, SP\0 := EP-[n args*3] - i.e., FP)
          5     W4
          4     BN        (block number)
          /5    1         (SP\1 := block number)
          4     ADPART
          6     &017760   (block number)
          5     BN
          4     EVN
          /5    2         (SP\2 := EVN)
          10    SP        (SP += 3)
          10    SP
          10    SP
PCHK4     4     EP        (more arguments to set up?)
          2     W4
          9     PCHK1     (yes, continue, otherwise check top of stack)

MAMPS4    4     WARNAD    (check for overwriting loader dictionary)
          2     SP
          9     DICTOK    (AJH mod: was 9 L2088)

          4     +3        (SP >= WARNAD)
          5     WARN
          4     STKEND    (AJH mod - code moved - STKEND > SP?)
          2     SP
          9     NXPORD
MAMPS5    4     FAILNS    (reached end of store)
          8     ENFAIL

DICTOK    /4    CODEPR    (AJH mod: was L2088 /4 1)
          2     SP        (check for overwriting code procs in dictionary)
          9     CODEOK    (AJH mod: was 9 L2094)
          4     +2        (SP >= CODEPR)
          5     WARN
          8     NXPORD

CODEOK    4     PDADD     (AJH mod: was L2094 /4 2)
          2     SP        (check for overwriting program entry in dictionary)
          9     NXPORD
          4     +1        (SP >= PDADD)
          5     WARN
          8     NXPORD

PRIM63    >1              (CONST:  write n-60 to SP[-3])
          4     +60
          2     ADPART
          0     W
          /5    1
          8     NXPORD

PCHK1     0     PP        (check procedure arguments
                                    - PP points to argument descriptors)
          /4    0
          10    PP        (increment PP)
          5     W2        (W2 := argument descriptor)
          14    8179      (type)
          9     PCHK2     (modifier set?)
          6     +15
          5     W3        (W3 := type)
          0     W4        (top of stack - type loaded)
          /4    1
          6     =15 8191  (CONn)
          2     W3
          7     PCHK3     (CONn matches type?)
          2     -4        (CONn = type+4?)
          7     ;+2
          8     PCHK7     (no - parameter mismatch)
          4     W3        (type = integer or real function?)
          1     -3
          9     PCHK3
PCHK7     4     FLNS5     (parameter mismatch error)
          8     ENFAIL

(value parameters: integer, integer array, real, real array, label)
PCHK2     6     +15       (modifier was set, so value parameter)
          1     -3
          9     PCHK5     (1,2 - scalar)
          1     -2
          9     COPYAR    (3,4 - value array needs to be copied)
(note no action for value label)

PCHK5     4     W4        (go on to next descriptor)
          1     +3
          5     W4
          8     PCHK4

(name parameters)
(address is number of dimensions or parameters, 8191 if not known)
PCHK3     4     W2        (descriptor)
          6     +8191
          5     W5        (W5 := address)
          4     W2
          6     +8191
          2     +8191
          7     PCHK5     (address = 8191 => dims etc not known)
          4     W3        (opcode)
          1     -3
          9     PCHK5     (1,2 scalars - nothing to do)
          1     -2
          9     PCHK8     (3,4 arrays - check dims)
          1     -3
          9     PCHK6     (5, 6, 7 function, procedure - check args)
          8     PCHK5     (no action for string)

(check procedure parameter)
PCHK6     0     W4        (stack)
          /0    0         (argument)
          /4    0         (PE n of procedure body)
          6     +15       (max 14)
PCHK9     2     W5
          7     PCHK5     (dims/args ok)
          8     PCHK7     (parameter error)

(check array dimensions)
PCHK8     0     W4        (stack)
          /0    0         (argument)
          /0    1         (map)
          /4    0         (dimensions)
          8     PCHK9

(Hunter modified CFF)
CFF       11    FINDFP    (call formal function)
          8     FINDFP+1  (find parameter)
          5     ADPART
          0     W1        (actual parameter slot)
          /4    2         (EVN of function)
          6     &377777   (might have bit 18 set if a thunk)
          8     JOIN2     (join CF)

(Hunter modified GTF, GT, GTFS, GTS)
GTF       11    FINDFP    (go to formal label)
          8     FINDFP+1
          0     W1        (check for call-by-name)
          /4    2
          7     ;+2
          8     BACK      (invoke thunk)
          /4    0         (old route)
          8     GT+1

GT        1     BASE+1    (goto n)
(+1)      5     W         (address of label on stack or in QACODL)
          0     W
          4     BN        (check if  label in current block)
          /2    1
          7     GTCURR    (yes - ok to jump)

          /4    1         (save target block number)
          5     SUBWK1+1
          4     EP
          5     SUBWK1+3
          0     EP        (current entry)

GTNXEP    /4    2         (check if a for entry)
          9     GTFOR
          /4    0         (check if EP' = ENV')
          /2    4
          7     GTFOR     (EP' = ENV', treat as for entry)
          /4    4
          5     LOC       (target entry for search)
          4     +0
          5     SUBWK1+2
GTNXEV    /4    0         (check not fallen off stack)
          2     STKBASE
          9     ;+2
          8     GTERR
          /0    0         (go to next entry)
          /4    0         (check if points to target)
          5     SUBWK1+3
          2     LOC
          7     GTEVFD
          /4    3         (check if matches target block)
          2     SUBWK1+1
          7     GTEVB
          8     GTNXEV    (continue searching)

GTEVB     /4    0         (remember target block seen)
          5     SUBWK1+2
          8     GTNXEV    (and continue searching)

GTFOR     /4    3         (test to see if target block)
          2     SUBWK1+1
          7     GTPREV    (target block found)
          /4    0         (not found - check not off end of stack)
          5     SUBWK1+3
          2     STKBASE
          9     ;+3

GTERR     4     +24       (attempt to jump to inner block)
          8     ENFAIL

          /0    0         (keep looking)
          8     GTNXEP

GTEVFD    4     SUBWK1+2  (see if target block was passed)
          7     GTFOR
          0     SUBWK1+2  (reset pointer and exit)

GTPREV    /4    0         (set up previous entry as current)
          5     EP
          /4    2
          9     GTFEX     (in a for entry)
GTSP      5     SP
          /4    3
          5     BN
GTCURR    0     W         (set PP to destination, absolute)
          /4    0         (label address relative)
          1     STKMOD    (label address absolute)
          5     PP        (set PP)
          8     NXPORD

GTFEX     4     SUBWK1+3
          8     GTSP

GTFS      11    FINDFP    (go to formal switch)
          8     FINDFP+1
          8     GTS+1

GTS       1     BASE+1    (goto switch)
          5     W         (address of switch table in QACODL)
          4     +3
          2     SP
          5     SP        (index is on stack)
          0     SP
          /4    0         (index)
          9     GTSFAIL   (must be >= 0)
          7     GTSFAIL
          0     W
          /2    0         (check index <= upper bound)
          9     GTSFAIL
          0     SP
          4     +1
          /2    0
          /1    0         (calculate index in switch list - W+index-1)
          1     W
          8     GT+1      (join goto)

TFAI                      (take formal argument integer)
TFAR                      (take formal argument real)
TFVI
TFVR      11    FINDFP    (search for argument)
          8     FINDFP+1
          0     W1
          /4    1         (copy word 1)
          0     SP
          /5    1
          0     W1
          /4    0
          5     W1        (W1 := word 0)
          /4    2         (word 2)
          0     SP
          8     CLEAR1    (join CLEAR to set word 0, 2)

TRCN      11    FINDFP    (take result call by name)
          8     FINDFP+1
          0     W1
(+3)      /4    2         (test flag in word 2)
          7     TRCN1     (old route)
          /4    1         (unpick thunk type)
          1     -3
          9     ADPORD    (arrays)
          8     BACK      (scalars and functions)

TRCN1     /4    1         (type)
          9     TRCN2
          /4    0         (address)
          5     W+1
          9     STKRLV    (real)
          0     W+1       (integer)
          /4    0         (fetch value)
          8     TA1

TRCN2     /4    0         (indirect through address)
          5     W1
          8     TFVR+2    (and join TFAI)

MAMPS9    4     FLNS21
          8     ENFAIL

MAMPS     14    8187      (make array)
          6     +126
          5     W9        ([n / 64] * 2 = dimensions * 2)
          1     W9
          1     W9        (W9 := 6 * dims)
          2     SP
          5     W9        (W4,5,9 := SP - 6 * dims)
          5     W5
          5     W4
          0     PP
          /4    0
          6     =/0 0
          5     W2        (W2 := real / int flag)
          7     ;+2
          4     +1
          1     +1
          5     W6        (W6 [total] = 1 for integer, 2 for real)
          /4    0         (address relative to QAVNDA)
          6     +8191
          1     BASE+2
          5     WS        (WS := absolute address of first array descriptor)
          4     ADPART
          14    1
          6     +126      ([n & 63] * 2: number of arrays to make)
          1     WS
          5     WS1       (WS1 := absolute address of last array descriptor)
          0     W4        (stack)
          4     W2
          7     ;+2       (integer array?)
          /4    0         (lwb)
          /1    0         (2 * lwb)
          2     +0
          5     W7        (W7 [offset] := [int] -lwb; [real] -2 * lwb)
MAMPS2    /4    0
          5     WS2       (WS2 := lwb)
          0     W4        (stack)
          /2    3         (test upb < lwb)
          9     MAMPS9    (if so, error 21)
          1     +1        (upb-lwb+1)
          12    W6        (* W6 [total])
          3     W6        (updated total)
          0     W5        (map)
          4     WS2
          /5    3         (lwb to word 3)
          4     W4        (advance stack by 6)
          1     +6
          5     W4
          2     SP        (W4 = SP?)
          7     MAMPS1    (yes - all dimensions done)
          4     W6        (total)
          0     W5        (map)
          /5    4         (size to word 4)
          10    W5        (advance map by 2)
          10    W5
          0     W4        (stack)
          /4    0         (lwb)
          12    W6        (int/real)
          14    17
          2     W7        (offset)
          5     W7        (new offset)
          8     MAMPS2    (do next lwb, upb)

MAMPS1    4     W6        (all dimensions processed)
          0     W9        (map replaces bounds on stack)
          /5    1         (total)
          4     W7
          /5    2         (offset)
          4     ADPART
          14    8186
          6     +63
          /5    0         (dimensions)
          4     W5        (next pair address)
          1     +4        (+ 4)
          1     W2        (+ real flag)
          5     W5        (to W5)
MAMPS3    4     W5
          0     WS        (WS points to descriptor)
          /5    0         (address of data)
          1     W6        (int/real flag)
          5     W5        (address of next array)
          4     W9        (address of map)
          /5    1
          10    WS        (set up next descriptor)
          10    WS
          4     WS1       (more arrays to do?)
          2     WS
          9     MAMPS3    (yes, continue)
          10    PP        (no, advance PP and exit)
          4     W5        (SP := point after data)
          6     =15 8191
          5     SP
          8     MAMPS4    (check for stack overflow and exit)

COPYAR    0     W4        (copy array)
          /4    0
          5     W
          4     SP
          /5    0         (change descriptor address to stack top)
          0     W         (original descriptor)
          /4    1         (original map)
          0     SP
          /5    1         (copy to new descriptor)
          5     W1        (w1 := original map)
          0     W
          /4    0         (original data)
          6     =/0 0     (preserve flag)
          1     SP
          1     +2        (SP+2 = copy area base)
          0     SP
          /5    0         (new data)
          6     =15 8191
          5     W2        (copy area pointer)
          0     W1
          /4    1         (new stack top = total size)
          1     W2        (+  copy area)
          5     SP        (check for stack overflow)
          2     STKEND
          9     MAMPS5
          0     W         (copy across the data)
          /4    0
          5     W1
CPYAR1    0     W1        (original)
          /4    0
          0     W2
          /5    0         (copy)
          10    W2
          10    W1
          4     SP
          2     W2
          9     CPYAR1
          8     PCHK5

INDSFL    4     FAILNS+2  (error 4 - switch subscript out of bounds)
          8     ENFAIL

INDFS     11    FINDFP    (index formal switch)
          8     FINDFP+1
          8     ;+2
INDS      1     BASE+1    (index switch)
          5     ADPART    (absolute address via QAVNDA)
          4     +3
          2     SP
          5     W         (W := SP-3)
          0     W
          /4    0
          9     INDSFL    (<= 0 is a fail)
          7     INDSFL
          0     ADPART
          /2    0
          9     INDSFL
          4     +1
          2     ADPART
          0     W
          /1    0
          /1    0
          /5    0
          8     NXPORD

AINDSB    >1              (array index subroutine)
          4     ADPART    (stack has array address and indices)
          2     SP
          5     W+5       (W5 := position of first index)
          1     -3
          5     W+6       (W6 := position of array address)
          0     W+6
          /4    0         (W :=  address of descriptor)
          5     W
          0     W
          /4    1         (W1, W7 := address of map)
          5     W1
          5     W7
          /4    0         (address of data)
          6     &400000
          0     W+5
          7     ;+2       (test of integer array)
          /4    0         (current index)
          /1    0         (doubled if real)
          0     W+1       (map)
          /1    2         (add to  offset)
AINDS1    5     W+3       (W3 := address within data)
          4     W+5
          1     +3
          5     W+5       (position of next index on stack)
          2     SP
          7     AINDS2    (all indices processed?)
          0     W+5
          /4    0         (next index)
          0     W+1       (map)
          /12   4         (* size of previous dimension)
          14    17
          10    W+1       (advance map pointer)
          10    W+1
          1     W+3       (add to offset)
          8     AINDS1    (do next index)

AINDS2    4     W+6       (put array address on stack)
          5     SP
          0     W+7
          /4    1         (total length of array)
          2     W+3       (address within data)
          9     ;+3       (check bounds)
INDWRG    4     FAILNS+3  (error 3)
          8     ENFAIL
          4     W+3       (check bounds)
          9     INDWRG
          0     W         (address of data [ & flag ])
          /1    0         (add to address within data)
          0     AINDSB
          /8    1

INDA      11    AINDSB    (index address)
          8     AINDSB+1
          9     TRAP3     (join TRA for real)
          8     TIA+1     (join TIA for integer)

INDR      11    AINDSB    (index result)
          8     AINDSB+1
          5     W+1
          9     STKRLV    (join TRR)
          0     W+1
          /4    0
          8     TA1       (join TIR)

CBL       4     PP        (call block)
          1     +1
          5     ADPART    (set ADPART to UJ following CBL)
          8     JOIN1

CF        4     ADPART    (call function)
          1     STKMOD
          5     ADPART
JOIN1     4     EP        (EP is environment)
JOIN2     5     EVN       (EVN of function is environment)
          0     SP        (stack EP)
          4     EP
          /5    0
          4     PP        (stack PP)
          /5    1
          4     SP
          5     EP        (EP := SP)
          10    SP
          10    SP        (SP +:= 2)
          4     ADPART    (set PP)
          5     PP
          8     NXPORD

(AJH modification CF global identifier)
CFSIR     1     -32
          9     PEM-1     (n <= 31 => PEM)
          1     BASE      (calculate absolute address)
          5     ADPART
          8     JOIN1     (rejoin main CF code)

ST        11    STSUBRT   (Store)
          8     STSUBRT+1 (store value on stack into address on stack)
          4     W
          5     SP        (reset stack pointer)
          8     NXPORD

STA       11    STSUBRT   (store also)
          8     STSUBRT+1 (store value on stack into address on stack)
          0     W         (leave value on stack for subsequent ST or STA)
          /4    3
          /5    0
          /4    4
          /5    1
          /4    5
          /5    2
          8     NXPORD

DO        11    STSUBRT   (do - execute body of for statement)
          8     STSUBRT+1 (store next value in controlled variable)
          0     EP
          4     PP        (save PP in EP\1 [next])
          /5    1
          /4    2         (address of body)
          6     =15 8191  (mask off top bit)
          5     PP        (set as new PP)
          8     NXPORD

STEP      11    STSUBRT   (step)
          8     STSUBRT+1 (store stacked value in controlled variable)
          4     PP        (while joins here)
          0     EP
          /5    1         (set iterator to next instruction)
          4     +0
          /5    7         (second word of controlled variable address frame)
          8     NXPORD

FOR       0     SP        (start a for statement)
          4     EP
          /5    0         (new EP\0 [ EP'] := EP)
          0     PP
          /4    0
          1     =/0 0
          1     STKMOD
          0     SP        (new EP\2 [body] := bit18+abs address of body)
          /5    2
          4     BN
          /5    3         (new EP\3[BN']  := BN - block number)
          0     PP
          /4    1
          5     BN        (BN := PP\1 [block])
          /4    2
          1     STKMOD
          0     SP
          /5    4         (new EP\4 [exit] := PP\2+STKMOD)
          4     SP
          5     EP        (EP := SP)
          1     +5
          5     SP        (SP +:= 5)
          4     PP
          1     +3
          5     PP        (PP +:= 3)
          1     +1
          /5    1         (new EP\1 [next] := PP+4)
          8     NXPORD

FR        0     EP        (for return)
          /4    1
          5     PP        (PP := next)
          8     NXPORD

FSE       0     EP        (for statement end)
          /4    3         (previous block number)
          5     BN
          /4    4         (PP := exit)
          5     PP
          4     EP
          5     SP        (previous SP)
          /4    0         (previous EP)
          5     EP
          8     NXPORD

NEGI      4     +3        (negate integer)
          2     SP
          5     W
          0     W
          /4    0
          2     =/0 0
          7     NEGIE
          /4    0
          2     +0
          /5    0
          8     NXPORD

UNTIL     4     +6        (until - assumes step and limit on stack)
          2     SP
          5     SP        (unstack step and limit)
          0     EP
          /4    5         (address of controlled variable)
          9     UNTLR2    (real)
          /4    11        (stacked limit)
          /0    5         (controlled variable)
          /2    0
TEST      7     UNTIL3    (reached limit?)
          0     EP
          6     =/0 0     (sign bit)
          /2    8
          9     UNTIL3
UNTIL2    8     STEP+2

(Hunter modification)
STEP2     0     EP
          /4    7         (test and increment STEP flag)
          /10   7
          7     NXPORD    (first step)
          /4    5
          9     UNTILR    (is controlled variable real?)
          /4    8         (step)
UNTIL4    /0    5         (address of controlled variable)
          /1    0         (add)
          /5    0         (store in controlled variable)
          8     NXPORD

WADDR     0     W
GETRL2    0     EP
          /4    6
          /0    5
          9     W345R2
          /4    0
          5     W3
          /4    1
          6     &777600
          5     W4
          /4    1
          14    11
          14    8181
          5     W5
          0     STAND
          /8    1

UNTILR    4     EP
          1     +5
          5     W
          11    RSTACK
          8     RSTACK+1
          11    STAND
          8     GETRL2
          4     W3ADDR
          5     W
          11    PRIM31
          8     PRIM31+3
          4     EP
          1     +5
          5     PKDADD
          11    STSUBRT
          8     STSUB
          8     NXPORD

UNTLR2    4     EP
          1     +8
          5     W
          11    RSTACK
          8     RSTACK+1
          11    STAND
          8     GETRL2
          4     W3ADDR
          5     W
          11    PRIM33
          8     PRIM33+3
          4     W3
          8     TEST

NULSTR    &074000
          &070140
          0     NULSTR
          0     NULSTR+1
          >1
          &070112         (check function string)
          &400000
          0     ;-2

CHKSBR    4     PRFA1     (save current prefix)
          5     CHKSBR-4
          4     CHKSBR-1  (set check prefix)
          5     PRFA1
          4     GLODEV    (set global output device)
          5     ODEV
          8     W345R     (set W3,4,5 from stack)

CHECKI    11    STAND     (checki)
          8     CHKSBR
          4     +6
          11    IOLNK
          8     OUTI5
          4     CHKSBR-4
          5     PRFA1
          8     NXPORD

CHECKR    11    STAND     (checkr)
          8     CHKSBR
          4     +8
          5     DIGN
          4     +1
          5     OPMD
          11    IOLNK
          8     OUTR+3
          8     CHECKI+5

          &070112
          &026462
          &654502
          &000040
          &070112
          &024641
          \LSE
          &020040
          0     ;-4

CHECKB    11    STAND     (checkb)
          8     CHKSBR+4
          4     W3
          7     ;+2
          4     -4
          1     CHECKB-1
(+6)      11    SBLNK2
          8     OSTSB
          8     NXPORD

CHECKS    11    STAND     (checks)
          8     CHKSBR+4  (set up arguments)
          4     CHKSBR-1
          11    SBLNK2    (output string)
          8     OSTSB
          4     SP
          1     -3
          5     SP
          4     W3
          8     CHECKB+6

OSTR1     5     SP
          4     ODEV1
          5     ODEV
          0     SP
          /4    0
          8     CHECKB+6

          &070101
          \FIN
          \ISH
          &010140
          0     ;-4

FINISH    4     +3        (stop)
          5     ODEV
          4     FINISH-1
          11    SBLNK2
          8     OSTSB
          11    PAUSRT
STOP      8     LPCTL
          8     STOP-1

WHILE1    0     EP
          4     PP
          /5    1
          8     NXPORD

WHILE     4     +3        (while)
          2     SP
          5     SP        (unstack boolean)
          0     SP
          /4    0
          7     WHILE1    (Hunter mod ignored)

UNTIL3    0     EP        (continue loop - execute body)
          /4    2         (PP :=  address of body)
          6     =15 8191
          5     PP
          8     NXPORD

STW       11    STSUBRT   (store while - store value in address)
          8     STSUBRT+1
          8     NXPORD

RTOI1     11    SBLNK     (real to integer)
          8     W345R
          11    SBLNK1
          8     RICONV
          0     W
          /5    0
          8     NXPORD

ITOR1     4     +3        (integer to real)
          8     ;+2
ITOR2     4     +6
          2     SP
          5     W
          0     W
          /4    0
          11    STAND
          8     ITRSB1
          11    RRES
          8     RRES+1
          8     NXPORD

NEGR      4     SP        (negate real)
          1     -3
          5     W
          11    STAND
          8     NEGR1
          8     NXPORD

LDZERO    +0
INOEX     0     IOLNK
          /8    1
RNDTBL    8     0
          +26214
          +10485
          +4194
          +1677
          +671
          +268
          +107
          +43
          +17
          +7
          +3
          +1
          +0
          +0
          +0

INOUT     2     +31       (input-output)
          9     TASIR	  (INOUT n n >=32 is mapped to TASIR)
          1     -16
          9     INOUT1
          4     +0
INOUT2    5     W10
          4     +3
          2     SP
          5     W         (final SP)
          0     ADPART
          /0    INOUT3    (branch on address)
          11    IOLNK
          /8    0
          8     NXPORD

INOUT1    4     +7        (INOUT 0-15 take an entry off the stack)
          8     INOUT2

INOUT4    4     -7
          5     WS
INOUT5    0     WS
          /4    GLOPMD+7
          /5    GLOPMD+14
          10    WS
          4     WS
          9     INOUT5
          8     NXPORD

SMLN      4     NULSTR+2
          8     PRFX1
PRFX      5     SP
          0     W
          /4    0
PRFX1     0     W10
          /5    GLPRFA

INOUT3    8     NXPORD    ( 0 do nothing)
          0     RDNM      ( 1 read integer)
          0     RDNM      ( 2 read real)
          0     OUTI      ( 3 output integer)
          0     OUTR      ( 4 output real)
          0     ALGN      ( 5 align - global)
          0     DEST      ( 6 punch - global)
          0     DIGIT     ( 7 digits - global)
          0     FRPNT     ( 8 freepoint - global)
          0     SPARE     ( 9 spare)
          0     SPARE     (10 spare)
          0     PRFX      (11 prefix - global)
          0     SMLN      (12 sameline - global)
          0     SCLD      (13 scaled - global)
          0     SRCE      (14 reader - global)
          0     OSTR1     (15 output string)
          0     ALGN      (16 aligned - local)
          0     DEST      (17 punch - local)
          0     DIGIT     (18 digits - local)
          0     FRPNT     (19 freepoint - local)
          0     INOUT4    (20 reset global)
          0     SPARE     (21 spare)
          0     PRFX      (22 prefix - local)
          0     SMLN      (23 sameline - local)
          0     SCLD      (24 scaled - local)
          0     SRCE      (25 reader - local)

FRPNT     5     SP
          0     W
          /4    0
FRPNT1    0     W10
          /5    GLDIGN
          5     W1
          4     +0
          /5    GLOPMD
INOUT9    4     W1
          1     -1
          9     FRPNT2
          1     -8
          9     NXPORD
FRPNT2    4     +7
          8     FRPNT1

ALGN      1     -3
          5     SP
          5     W
          0     W
          /4    3
          0     W10
          9     FRPNT2
          /5    GLDIGN
          4     -1
          /5    GLOPMD
          0     W
          /4    0
          0     W10
          9     FRPNT2
          /5    GLDIGM
          /1    GLDIGN
          7     FRPNT2
          2     +15
          9     FRPNT2
          8     NXPORD

SCLD      5     SP
          0     W
          /4    0
          0     W10
          /5    GLDIGN
          5     W1
          1     -2
          9     FRPNT2
          4     +1
          /5    GLOPMD
          8     INOUT9

DEST      5     SP
          0     W
          /4    0
DEST1     0     W10
          /5    GLODEV
          9     DEST2
          7     DEST2
          1     -11
          9     NXPORD
DEST2     4     +1
          8     DEST1

SRCE      5     SP
          0     W
          /4    0
SRCE1     0     W10
          /5    GLIDEV
          9     SRCE2
          7     SRCE2
          1     -11
          9     NXPORD
SRCE2     4     +1
          8     SRCE1

DIGIT     5     SP
          0     W
          /4    0
DIGIT1    0     W10
          /5    GLINTD
          1     -1
          9     DIGIT2
          1     -12
          9     NXPORD
DIGIT2    4     +6
          8     DIGIT1

DIVTEN    0     W4
          14    1
          4     W3
          14    8188
          13    TENPWR
          14    18
          5     SBW
          14    3
          12    TENPWR
          14    1
          3     SBW2
          5     SBW1
          4     SBW2
          2     W4
          9     ;+2
          8     ;+3
          10    SBW1
          6     =15 8191
          5     SBW2
          4     SBW1
          2     W3
          5     SBW1
          0     SBW2
          14    1
          4     SBW1
          14    11
          13    TENPWR
          0     +0
          14    8177
          3     W4
          1     SBW
          5     W3
          0     STAND
          /8    1

DECML5    4     +4
          1     W5
          5     W5
DECML     0     W4
          14    1
          4     W3
          14    8188
          3     W4
          5     W3
DECML1    0     W4
          14    1
          4     W3
          14    1
          3     W4
          5     W3
          14    2
          3     SBW
DECML4    1     W3
          5     W3
          4     SBW
          1     W4
          9     DECML2
DECML3    5     W4
          0     STAND
          /8    1
DECML2    6     =15 8191
          10    W3
          8     DECML3

OUTR      5     SP
          4     ODEV1
          5     ODEV
          4     DIGN1
          5     DIGN
          4     DIGM1
          5     DIGM
          4     OPMD1
OUTR2     5     OPMD
          11    STAND
          8     W345R1+1
          4     +4
          8     OINT2

OUTI      5     SP
          4     ODEV1
          5     ODEV
          0     W
          /4    0
OUTI4     5     W3
          4     INTDG
OUTI5     5     DIGM
          4     +0
OINT2     5     ADPART
          4     LDZERO
          5     NSIGNF
(+3)      4     +0
          5     SIGNCH
          4     PRFA1
          11    SBLNK2
          8     OSTSB
          4     ADPART
          7     OUTI3
OINT3     4     +0
          5     DECPWR
          4     W3
          9     OPRL1
          7     OPRL19
          14    1
          9     OPRL3
OPRL2     4     FLNS6
          11    PAUSRT
          8     FAILEN
          4     +10
          11    OTCHA
          8     OTCHA1
          11    OTCHA
          8     OTCHA2
          11    OTCHA
          8     OTCHA2
          8     INOEX

OPRL1     14    1
          9     OPRL2
          0     W3ADDR
          11    STAND
          8     NEGR6
          4     +13
          5     SIGNCH
OPRL3
OPRL4     4     W5
          9     OPRL12
          4     &310000
          5     TENPWR
OPRL5     4     W5
          9     OPRL10
          7     OPRL11
          4     +5
          2     W5
          9     OPRL8
          1     +2
          5     W5
          10    DECPWR
OPRL9     11    STAND
          8     DIVTEN
          10    DECPWR
          11    STAND
          8     STAND+1
          8     OPRL5

OPRL8     4     =10 0
          5     TENPWR
          8     OPRL9

OPRL18    10    DECPWR
          4     &031463
          5     W3
          4     &063160
          5     W4
          8     OPRL20

OPRL19    10    DECPWR
          4     W4
          7     OPRL20
          8     OPRL2

OPRL13    4     &314631
          2     W3
          9     OPRL14
          7     ;+2
          8     OPRL10
          4     &231463
          2     W4
          9     OPRL14
          8     OPRL10

OPRL14    4     W5
          1     +4
          5     W5
          11    STAND
          8     DECML
          11    STAND
          8     STAND+1
OPRL15    4     +1
          2     DECPWR
          5     DECPWR
OPRL12    4     W5
          1     +3
          9     OPRL14
          7     OPRL13
OPRL10    4     W5
          11    STAND
          8     SHIFTD
OPRL11    4     OPMD
          7     ;+4
          9     ;+6
          4     DIGN
          8     ;+6
          4     DECPWR
          9     ;+3
          8     ;-4
          4     DECPWR
          1     DIGN
          9     OPRL20
          5     SBW1
          1     SBW1
          2     +0
          5     SBW
          0     SBW1
          /4    RNDTBL
          0     SBW
          /14   0
          3     SBW
          11    STAND
          8     DECML4
          4     W3
          9     OPRL18
OPRL20    4     OPMD
          7     OPRL21
          9     OPRL22
          4     +1
          2     DIGN
OPRL25    5     AFTPT
          4     +1
          5     BEFPT
          11    SBLNK1
          8     OTMX1
          4     +16
          5     NSIGNF
          4     +11
          5     SIGNCH
          4     +31
          11    OTCHA
          8     OTCHA1
          4     DECPWR
          1     -1
          5     W3
          4     +2
          5     DIGM
          4     +0
          5     ADPART
OUTI3     5     W4
          5     DIGN
          4     -1
          5     OPMD
          4     +17
          5     W5
          11    STAND
          8     STAND+1
          8     OINT3

OPRL27    4     +0
          8     OPRL28

OPRL21    4     DECPWR
          9     OPRL27
OPRL28    5     BEFPT
          2     DIGN
          9     OPRL24
OPRL23    5     AFTPT
          11    SBLNK1
          8     OUTMXD
          8     INOEX

OPRL22    4     DECPWR
          2     DIGM
          9     OPRL29
          4     DIGM
          5     BEFPT
          4     DIGN
          8     OPRL23

OPRL29    4     DIGM
          1     DIGN
          5     DIGN
OPRL24    4     ADPART
          6     +8191
          7     ;+2
          4     +1
          1     DIGN
          1     -6
          9     OPRL26
          1     +1
          5     DIGN
          4     +1
          5     OPMD
          5     ADPART
          8     OPRL11

OPRL26    2     -6
          11    OTCHA
          5     SW
          4     SW
          10    SW
          7     ;+3
          4     +0
          8     OTCHA1
          4     +40
          11    OTCHA
          8     OTCHA1
          8     INOEX
OUTMXD    4     DECPWR
OTMX1     5     SW1
OTMX2     4     BEFPT
          7     OTMX4
          1     AFTPT
          7     OTMX13
OTMX3     4     SW1
          2     BEFPT
          9     OTMX7
          7     OTMX6
          4     BEFPT
          1     -1
          7     OTMX11
          4     NSIGNF
          5     SW
          7     OTMX10
          8     OTMX9

OTMX11    4     +16
          5     SW
          8     OTMX9
OTMX4     4     AFTPT
          7     OTMX12
          4     +16
          5     NSIGNF
          4     SIGNCH
          9     OTMX5
          11    OTCHA
          8     OTCHA1
          4     -1
          5     SIGNCH
OTMX5     4     +14
          11    OTCHA
          8     OTCHA1
          8     OTMX3

OTMX6     11    STAND
          8     DECML
          8     OTMX8

OTMX7     11    STAND
          8     DECML1
OTMX8     4     W3
          14    8179
          1     +16
          5     SW
          4     W3
          6     +8191
          5     W3
OTMX9     4     SIGNCH
          9     OTMX10
(+2)      11    OTCHA
          8     OTCHA1
(+4)      4     -1
          5     SIGNCH
OTMX10    4     SW
          11    OTCHA
          8     OTCHA1
          4     BEFPT
          1     -1
          5     BEFPT
          8     OTMX2
OTMX12    4     ADPART
          7     OTMX13
          4     +0
          11    OTCHA
          8     OTCHA1
OTMX13    0     SBLNK1
          /8    1

RDNM26    4     FLNS19
          11    PAUSRT
          8     FAILEN
          11    GECHAR
          8     GECHEN
RDNM      4     +0
          5     W1
          5     W2
          5     W3
          5     W4
          5     W5
          5     W6
          5     W7
          5     W9
          5     WS20
          4     =/0 0
          5     W8
          8     ;+5
          4     WS22
          5     W2
RDNM1     11    GECHAR
          8     GECHEN
          0     IDEV
          /4    BUFFER-1
          5     WS21
          0     WS21
          /4    TABLE
          6     =8 0
          7     RDNM3
          10    W1
          10    WS20
          4     W7
          7     RDNM2
          0     +0
          4     W9
          1     W9
          5     W9
          14    2
          1     W9
          1     WS21
          1     -16
          5     W9
          2     +28
          9     ;+2
          8     RDNM1
          1     W9
          8     ;-5

RDNM2     10    W8
          11    STAND
          8     DECML5
          4     W5
          2     +17
          6     +8191
          1     SHFT1
          5     ;+4
          4     WS21
          1     -16
          0     +0
          +0
          3     SBW
          11    STAND
          8     DECML4
          11    STAND
          8     STAND+1
          8     RDNM1

RDNM5     4     W6
          10    W6
          7     RDNM6
RDNM7     4     FLNS17
          8     RDNM26+1

RDNM6     5     W8
          8     RDNM1

RDNM8     4     +1
RDNM9     5     WS22
          4     WS20
          7     RDNM1-2
          8     RDNM27

RDNM10    5     WS20
          4     W7
          7     RDNM11
          8     RDNM7

RDNM11    10    W7
          4     W1
          7     RDNM12
RDNM13    4     W2
          5     W10
          4     +0
          5     W2
          10    W6
          8     RDNM1

RDNM12    4     =8 0
          5     W3
          4     +1
          5     W5
          10    W1
          8     RDNM13

RDNM3     4     WS21
          1     -14
          7     RDNM5
          1     -17
          7     RDNM10
          1     +18
          7     RDNM8
          1     +2
          7     RDNM9
          1     +4
          7     RDNM26
RDNM27    4     W1
          7     RDNM1
          4     W7
          7     RDNM14
          4     W2
          7     RDNM4
          4     W9
          2     +0
          5     W9
RDNM4     4     W10
          5     W2
RDNM14    4     W8
          9     RDNM15
          2     W9
          5     W9
RDNM15    4     W9
          7     RDNM20
          9     RDNM16
          1     -1
          5     W9
          11    STAND
          8     DECML5
RDNM19    11    STAND
          8     STAND+1
          8     RDNM15
RDNM16    4     W3
          7     RDNM20
          10    W9
          4     =10 0
          5     TENPWR
          11    STAND
          8     DIVTEN
          8     RDNM19

RDNM20    4     W2
          7     ;+4
          0     W3ADDR
          11    STAND
          8     NEGR6
          4     ADPART
          2     +2
          7     ;+3
          11    SBLNK1
          8     RICONV
          4     W
          5     SP
          5     PKDADD
          11    STSUBRT
          8     STSUB
          8     INOEX
          0     SBLNK2
          /8    1

OSTSB     5     WS2
          4     -12
          5     WS3
          4     -1
          5     WS6
          5     WS4
OST2      0     WS2
          /4    0
          0     WS3
          /14   0
          6     +63
          5     WS5
          4     WS3
          7     OST1
          1     +6
OST3      5     WS3
          4     WS4
          9     OST4
          7     OST6
          0     WS5
          /4    TABLE
          6     =8 0
          7     OST5
          4     WS6
          12    +10
          14    17
          1     WS5
          1     -16
          5     WS6
          8     OST2

OST1      4     -12
          10    WS2
          8     OST3

OST4      4     WS5
          1     -7
          7     OST2-1
          4     +23
          8     ENFAIL
          4     +1
          8     OST2-1

OST6      4     WS5
          1     -7
          7     OST6-2
          1     -25
          7     OSTSB-2
          4     WS5
          11    OTCHA
          8     OTCHA1
          8     OST2

OST5      4     WS6
          9     OST9+3
          4     WS7
          1     -34
          7     OST11
          4     WS6
          1     -2
          5     WS6
          9     OST9
          4     WS14
          11    OTCHA
          8     OTCHA1
          4     WS6
          1     -1
          8     ;-7
          4     =/0 0
          8     ;+2
OST8      4     HALTCH
          8     OST8+8
          4     +1
          5     WS7
          4     LFCH+1
          8     OST8+9
          1     +25
          1     +7
          5     WS7
          5     WS14
          4     +0
          5     WS6
          8     OST2

OST11     4     WS6
          1     =/0 0
          5     WS7
          4     -1
          5     WS6
OST9      4     WS7
          11    OTCHA
          8     OTCHA1
          4     WS5
          5     WS7
          1     -32
          7     OST2-1
          1     -2
          7     OST8+10
          1     -6
          7     OST8
          1     -4
          7     OST8+2
          1     -5
          7     OST8+7
          1     -1
          7     OST8-2
          1     -1
          7     OST8+8
          1     -2
          7     OST8+6
          4     FLNS7
          11    PAUSRT
          8     FAILEN
          8     OST8+2

[ SERIES FPA DLMULT ]
SERIES    >1
          4     +0
          11    DLMULT
          5     FPA+1
          0     SERIES
          /1    1
          5     FPA
          /4    2
          10    SERIES
          1     FPA+1
          10    SERIES
          9     OVERFLOW
RETURN    5     FPA+1
          /4    4
          /9    5
          8     DLMULT+1
OVERFLOW
          6     =15 8191
          10    FPA
          8     RETURN

[ DLDIV W3 W4 WS ]
DLDIV     +0
          4     W3
          5     WS+13
          4     W4
          5     WS+14
          0     +0
          14    8191
          3     WS+16
          5     WS+15
          4     +0
          5     WS+30
          5     WS+29
          0     +0
          4     WS+13
          13    WS+17
          5     WS+32
          12    WS+17
          3     WS+20
          5     WS+19
          4     WS+20
          7     NOCARRY
          2     +131071
          1     +1
          5     WS+20
          4     WS+19
          2     WS+13
          1     -1
          8     ;+3
NOCARRY   4     WS+19
          2     WS+13
          5     WS+19
          4     WS+32
          12    WS+18
          14    8191
          3     WS+33
          2     WS+15
          5     WS+21
          4     WS+33
          2     WS+16
          5     WS+22
          9     SUBTI
          4     WS+21
          8     ;+4
SUBTI     4     WS+21
          1     -1
          5     WS+21
          7     L0
          9     LNEG
LPOS      14    1
          10    WS+30
          9     JUMP1
          8     ;-3
L0        4     +16
          5     WS+30
          8     JUMP1
LNEG      0     +0
          14    1
          10    WS+30
          9     ;-2
JUMP1     4     WS+19
          7     JUMP2
          1     +1
          7     JUMP2
          1     -1
          14    8191
          10    WS+29
          8     ;-6
JUMP2     4     WS+29
          1     WS+30
          2     +1
          7     N1
          4     WS+29
          2     +16
          5     WS+28
          1     =14 0
          5     SHIFT2
          4     WS+29
          2     +0
          6     &17777
          1     =14 0
          5     SHIFT1
EVALUATE
          0     WS+22
          14    1
          4     WS+21
SHIFT1    14    0
          3     WS+22
          5     WS+21
          0     WS+20
          14    1
          4     WS+19
SHIFT2    14    0
          3     WS+23
          1     WS+21
          5     WS+24
          4     WS+23
          1     WS+22
          5     WS+25
          9     ADDI
          8     ;+2
ADDI      10    WS+24
          0     WS+25
          14    1
          4     WS+24
          14    8191
          13    WS+17
          5     WS+26
          4     WS+28
          2     =15 1
          5     SHIFT3
          0     +0
          4     WS+26
SHIFT3    14    0
          3     WS+29
          3     W4
          1     WS+32
          5     W3
          5     WS+28
          0     DLDIV
          /8    1
N1        4     =14 8191
          5     SHIFT1
          4     =14 15
          5     SHIFT2
          4     +15
          5     WS+28
          8     EVALUATE

[ TABLE ]
TABLE     /0    67
          /0    192
          2     192
          2     64
          2     192
          2     64
          2     64
          2     2243
          2     2240
          2     2048
          2     2625
          2     2752
          2     2112
          2     2755
          2     4288
          2     2624
          8     192
          8     64
          8     64
          8     192
          8     69
          8     192
          8     192
          8     64
          8     64
          8     192
          2     2240
          2     2112
          2     2496
          2     2368
          2     2368
          2     4288
          2     128
          4     66
          4     2
          4     131
          4     4
          4     133
          4     134
          4     7
          4     8
          4     137
          4     138
          4     11
          4     140
          4     13
          4     14
          4     143
          4     16
          4     145
          4     146
          4     19
          4     148
          4     21
          4     22
          4     151
          4     152
          4     25
          4     26
          2     2203
          2     28
          2     2205
          2     2718
          2     31
          /4    160
          /1    5153
          4     2082
          /4    3235
          4     4132
          /4    5285
          /4    6310
          4     7207
          5     40
          /5    1193
          /5    2218
          5     3115
          /5    4268
          5     5165
          5     6190
          /5    7343
          6     48
          /6    1201
          /6    2226
          6     3123
          /6    4276
          6     5173
          6     6198
          /6    7351
          /7    184
          7     1081
          7     2106
          /7    3259
          &170003         (was 7 4156) (convert old pound to new pound on 
                          input)
          /7    5309
          /7    6334
          7     7232
          &300040         (was/8 66) (permit new grave on input and only
                                                                    grave on 
                          output)
          8     1185
          8     2210
          /8    3107
          8     4260
          /8    5157
          /8    6182
          8     7335
          9     168
          /9    1065
          /9    2090
          9     3243
          /9    4140
          9     5293
          9     6318
          /9    7215
          10    176
          /10   1073
          /10   2098
          10    3251
          /10   4148
          10    5301
          10    6326
          /10   7223
          /11   56
          11    1209
          11    2234
          &666007         (was /11 3136) (permit open curly bracket on input)
          &506300         (was 11 4288) (convert old pound to new pound on 
                          output)
          &672040         (was /11 5184) (permit close curly bracket on input)
          /11   6208
          11    7363

[ OTCHA GECHAR GECHEN GECH OTCHA1 OTCHA2 TABLE LPCTL HALTCH FAILEN PAUSRT
BUFFER NEXTCH PCHLNK IDEV ODEV INSLOT OUTSLT SBLNK HALTMK SBW4 SBW3 SBW FLNS14
FLNS15 SBW5 LFCH OUTPA INPA STAND W1 STOP DEV SELTTY SELPTR ]

DEV       >1

OTCHA     >1
OTCHA1    5     SBW
OTCHA2    4     OTCHA
          5     PCHLNK+1
          4     SBW
          0     ODEV
          /0    OUTSLT-1
          /8    0

OUTPA     0     ;+4
          0     ;+1
          4     +6148
          8     ;+2
          4     +6144
          5     DEV
          4     SBW
          9     OTCHA6
OTCHA4    0     SBW
          /0    TABLE+64
          14    8
OTCHA6    0     DEV
          /15   0
          4     SBW
          1     -1
          7     ;+3
OTCHA5    0     PCHLNK+1
          /8    1
          4     LFCH
          /15   0
          4     +0
          /15   0
          8     OTCHA5

GECHAR    >1
GECH      4     STAND
          8     ;+2
GECHEN    4     GECHAR
          5     PCHLNK
          0     IDEV
          /0    INSLOT-1
          /8    0
INPA      0     ;+4
          0     ;+1
SELTTY    4     +2052
          8     ;+2
SELPTR    4     +2048
          5     DEV
          0     IDEV
          /4    BUFFER-1
          9     ;+3
          5     NEXTCH
GECHP1    8     GECH4
          11    PAUSRT
          8     LPCTL
          4     +1
          8     ;-5
GECH4     4     +0
          0     DEV
          /15   0
          5     SBW4
          6     +127
          5     SBW5
          0     SBW5
          2     SBW4
          /2    TABLE
          6     +128
          7     ;+3
          4     FLNS14
          8     GECH15
          /4    TABLE
          6     +127
          1     -64
GECHP4    9     GECH13
          5     SBW4
          0     SBW4
          /8    ;+1
          8     GECH9
          8     GECH11
          8     GECH99
          8     GECH4
GECHP2    8     GECH9
          4     =/0 1
GECH11    5     HALTMK
GECHP3    8     ;+2
GECH13    6     +63
          0     IDEV
          /5    BUFFER-1
          0     NEXTCH
          /4    TABLE
          0     PCHLNK
          /8    1
GECH99    4     +0
          15    2048
          15    6144
          7     GECH4
          8     ;-4
GECH9     4     FLNS15
GECH15    5     SUB12     (new code)
          4     +0
          5     SUB13
GECH16    0     SUB13
          /4    W1
          /5    SUB14
          10    SUB13
          4     SUB13
          2     +12
          7     ;+2
          8     GECH16
          4     SUB12
          11    PAUSRT
          8     FAILEN
          4     +0
          5     SUB13
GECH17    0     SUB13
          /4    SUB14
          /5    W1
          10    SUB13
          4     SUB13
          2     +12
          7     GECH13
          8     GECH17
SUB12     >1
SUB13     >1
SUB14     >12
LFCH      +10
          +1

HALTCH    /0    20

[ DUMP BASE DFLAG LLDR1 LLDR1A LPCTL T23LEN ]
(Dump utility)
DUMP      4     +0
          5     WORD
          5     SUM2
          5     SUM1
          4     +16383
          5     MAXADR    (highest address to punch)
          4     T23LEN    (addr of control loop)
          5     COUNT
DNEXT     4     +8        (loop punching T23)
          15    6144
          0     COUNT
          /4    MAXADR
          11    PUN3
          8     PUN3+1
          10    COUNT
          4     COUNT
          9     DNEXT
          4     +2        (loop punching out first segment)
          5     ADDR      (from 2 to [BASE]-1)
          4     BASE
          1     -1

NXTSEG    5     ENDAT     (punch next segment)
NXTBLK    0     ADDR
          /4    0
          7     ZERO
          4     +128      (start new block)
          5     WORD
          4     SUM1
          1     ADDR
          5     SUM1
          4     ADDR
          11    PUN3
          8     PUN3+1
NXTWD     0     ADDR
          /4    0
          7     ZERO
          5     WS
          11    PUN3
          8     PUN3+1
          4     WS
          1     SUM2
          5     SUM2
ZERO      4     ADDR
          2     ENDAT
          0     ADDR
          10    ADDR
          7     ENDSEG
          /4    0
          7     NXTBLK
          8     NXTWD
ENDSEG    4     +128      (end segment with checksums)
          15    6144
          4     +0
          15    6144
          15    6144
          4     SUM2
          11    PUN3
          8     PUN3+1
          4     SUM1
          11    PUN3
          8     PUN3+1
          4     ENDAT
          2     MAXADR
          7     DONE
          4     +0        (reset checksums)
          5     SUM2
          5     SUM1
          4     MAXADR    (punch BASE to MAXADR)
          8     NXTSEG
DONE      15    6148
          8     ;+0

PUN3      0     4215      (link - punch word subroutine)
          14    8174      (>> 18)
          4     +0
          14    4         (<< 4)
          1     WORD      (add to word)
          15    6144      (punch first 4 bits)
          4     +0
          5     WORD      (word := 0)
          14    7
          15    6144      (punch next 7 bits)
          4     +0
          14    7
          15    6144      (punch last 7 bits)
          0     PUN3      (return)
          /8    1

(T23 loader below stack -- takes over from T23 at top of store)
LOWLDR    5     SUM1
          5     SUM2
          4     DFLAG
          7     LLDR1
          4     LLDR1A
          5     6
          15    7168
          8     ;-1       (terminate on level 1 interrupt)
LLDR1     4     +0
          15    2048
LDONE     5     DATA
          6     +128
          7     LDWD
          4     DATA      (new block)
          15    2048
          15    2048
          7     SUMCK
          5     ADDR
          1     SUM1
          5     SUM1
LDCH      4     +0
          15    2048
          8     LDONE
LDWD      0     ADDR      (next word in block)
          4     DATA
          15    2048
          15    2048
          /5    0
          1     SUM2
          5     SUM2
          10    ADDR
          8     LDCH
SUMCK     15    2048      (sumchecks)
          15    2048
          15    2048
          2     SUM2
          7     ;+3
SFAIL     15    6144      (loop punching on sumcheck failure)
          8     ;-1
L4302     15    2048
          15    2048
          15    2048
          2     SUM1
          7     ;+2
          8     SFAIL
          4     DFLAG
          7     ;+0
          4     +0
          5     DFLAG
          8     LPCTL


(ALGOL T23 loader)

(This is the first loader punched out, it reads in the contents of memory
  upto and including LOWLDR which then takes over to load data above it.)

ALGT23    0     8179      (load 8 words  - clear store second module)
          8     8182
          -8
(8172)    +8192
          4     1
          2     8172
(8175)    7     8181      (load next section)
          /4    8191      (will have been left at +0 by i.i.)
          10    1
          /5    8191      (copy to next word)
          8     8173      (loop until 8192 words cleared)
(8180)    0     8179      (load 5 words - clear store first module)
          8     8182
          -5
          8     8177
          8     8181
(8177)    /5    2
          10    1
          8     8175
          0     8179
          8     8182      (load 45 words - T23 with different exit)
          -45
          4     8179
          15    2048
          7     8136
          5     8173
          6     8178
          7     8151
          4     8173
          15    2048
          15    2048
          7     8160
          5     8174
          1     8176
          5     8176
          4     8179
          15    2048
          8     8138
          0     8174
          4     8173
          15    2048
          15    2048
          /5    0
          1     8175
          5     8175
          10    8174
          8     8148
          15    2048
          15    2048
          15    2048
          2     8175
          7     8167
          15    6144
          8     8165
          15    2048
          15    2048
          15    2048
          2     8176
          7     LOWLDR    (at end of first segment go to lower loader)
          8     8165
DATA
COUNT     >1
ADDR      >1
SUM2      >1
SUM1      >1
          8     8135      (header for initial orders)
          +128
WORD      >1
MAXADR    >1              (highest address to dump)
ENDAT     >1
DFLAG     >1
WS        >1

%

*PROG LIBRY
*LISTLA
*NOMEM

^4252
[ ENDLIB ]

(vestigial library)

ENDLIB

%



*PROG LOADER
*LISTLA
*NOMEM

((ALGOL 16K LP SYSTEM Loader))


((LP Loader dictionary recovered from distributed binary))


[ LPSYMS ]

LPSYMS=7530^1             (empty symbol table)
^LPSYMS

[ BA BD PMODUL LA CR INTEGR W DP SADRES BLANK CLENUP OPTION STET ED READTH MODE
LBASE ALGFLG LW3 MMODUL EDNEG BEGLOA NULL LOW1 CONST FAIL E5TEST SUBSTI ENTRY
TONE TTWO LPSYMS ENDLIB LPCTL BASE ODEV GLOPMD STKMOD OLDLBD SBLNK2 OSTSB RET1
MESAGE FINAL RET2 RET3 IOLNK OUTI INTER RET4 RET5 STKBAS  WARNAD THUNK ]

QANAMS    +0              (this is BEGLOA-6)
          \QAC
          \ODL
          +0
          \QAV
          \NDA
BEGLOA    0     BEGLOA
          5     MODE      (start - referenced as BEGLOA+1)
          11    PMODUL
          14    18
          5     PMODUL
          2     +0
          5     MMODUL
          0     MMODUL    (bottom of stack)
          /4    BASE
          5     LBASE
          4     +3
          5     OPTION
          4     LBASE     (BASE points to QACODL; BASE+1 to QAVNDA)
          2     +132
          5     BEGLOA-6
          1     +1
          5     BEGLOA-3
          4     +8191
          0     MMODUL
          /5    BASE+1    (set QACODL, QAVANDA to +8191)
          /5    BASE+2
          4     CONST
          1     -3
          5     ED        (ED := CONST-3)
          2     -3
          5     EDNEG     (EDNEG := -CONST)
          4     +3        (set device no to 3 for display)
          /5    ODEV
          4     :NULL     (set null prefix)
          /5    GLOPMD+10 (GLOPMD+10 PRFA1)
          4     +5        (set no of digits to 5)
          /5    GLOPMD+11 (GLOPMD+11 INTDG)
          4     +0
          5     LASTSZ    (LASTSZ := 0)
          0     MODE
          /8    ;+0
          8     MODE1
          8     MODE2
          8     MODE3
          8     MODE4
          8     MODE5
          8     MODE6

(mode 1 - load ALGOL program)
MODE1     0     MMODUL
          /4    STKMOD
          5     LA        (LA := STKMOD)
          4     LASTBD
          5     BD        (BD := LASTBD)
          8     MODEOK

(mode 2 - load ALGOL program overwriting code procs)
(mode 5 - load code proc overwriting all other code procs)
MODE2
MODE5     4     PROGM
          5     LA
          5     LIBEND    (LA := LIBEND := PROGM)
          0     MMODUL
          /5    STKMOD    (STKMOD := PROGM)
          /4    OLDLBD
          5     BD
          5     LASTBD    (BD := LASTBD := OLDLBD)
          8     MODEOK

(mode 3 - load ALGOL overwriting code procs and library)
(mode 6 -  load new library)
MODE3
MODE6     0     MMODUL
          /4    BASE
          5     LA
          5     PROGM
          5     LIBEND    (LIBEND := PROGM := LA := BASE)
          /5    STKMOD    (STKMOD := BASE)
          4     +6        (reset dictionary)
          2     CONST
          5     BD
          5     DICT      (DICT := BD := CONST-6)
          /5    OLDLBD
          5     LASTBD    (LASTBD := OLDLBD)
          8     MODEOK

(mode 4 - load code proc)
MODE4     4     LIBEND
          5     LA        (LA := LIBEND)
          4     DICT
          5     BD        (BD := DICT)

MODEOK    4     LA        (clear free store)
          1     MMODUL
          5     W         (W := MMODUL)
          4     ALGFLG    (test if ALGOL)
          7     CLEAR
          4     LA        (ALGOL - set ALGST to LA)
          5     ALGST

CLEAR     0     W         (clear store from LA to BD)
          4     +0
          /5    0
          10    W
          4     W
          2     BD
          7     ;+2
          8     CLEAR
          4     LA
          5     FIRST     (FIRST := BA := LA)
          4     LA
          5     BA
CLRCR     4     +0        (CR := 0)
          5     CR

BLANK     4     +0        (read tape to first non-blank)
          15    2048
          7     BLANK

          5     LOW1
          14    8188
          5     LOW       (LOW := type bits)

          2     +6
          9     HALT      (type = 7 [halt])
          7     TEST      (type = 6 [checksum])

          4     LOW1      (read rest of word and update checksum)
          1     CR
          5     CR
          4     LOW1
          15    2048
          5     LOW1
          6     +127
          1     CR
          5     CR

          4     LOW1
          15    2048
          5     LOW1
          6     +127
          1     CR
          5     CR
          4     LOW1      (branch on type)
          0     LOW
          /8    ;+1

          8     FAIL1     (0 - patch, 000 / other, Error FA)
          8     STET      (1 - absolute)
          8     ADBASE    (2 - relative)
          8     THREE     (3 - resolve reference)
          8     FOUR      (4 - global)

(101 Integer  Skip
  LA +:= integer)
FIVE      1     LA        (5 - skip)
          5     LA        (LA +:= skip)
          4     ALGFLG
          7     ;+2
          8     BLANK     (loading ALGOL)

CK8180    4     +8179     (loading code proc - check below 8180)
          2     LA
          9     BLANK     (LA < 8179 - get next command)
          4     +26       (FZ error)
          8     FAIL

(010 Word  Store relative
  Add base address to word, and store word
  in [LA]; LA +:= 1)

ADBASE    4     ALGFLG    (relative address)
          7     ;+2
          8     STET+1    (ALGOL treated as absolute)
          4     LOW1      (code proc: LOW1 := LOW1+BA+LASTSZ)
          1     BA
          1     LASTSZ

(001 Word  Store absolute
  Store word in ([LA]; LA+:=1)

STET      5     LOW1      (absolute address)
          4     MMODUL    (W := LA [module relative])
          1     LA
          5     W
          0     W
          4     LOW1      (absolute address)
          /5    0         ([LA] := LOW1)
          10    LA        (LA +:= 1)

CHECK     11    E5TEST    (check not hit dictionary)
          8     E5TEST+1
          4     ALGFLG    (ALGOL or code proc?)
          7     CK8180
          8     BLANK     (loading ALGOL)

(011 Link Address - Resolve forward references
  Add base address to link address
  and the sum gives a link in the
  chain of store addresses, all of which
  are to have their addresses changed
  to the current LA+increment.  Last number of
        the chain contains address 8191)

THREE     11    READTH    (read three rows)
          8     READTH+1
          4     ALGFLG
          7     ;+2
          8     THALG     (loading ALGOL)

          4     LBASE     (loading code proc)
          2     INTEGR
          1     LA
          5     SADRES    (SADRES := INTEGR+LA-BASE)

          4     LOW1      (location to update LOW1+BA+LASTSZ)
          1     BA
          1     LASTSZ
          11    SUBSTI    (fix up)
          8     ENTRY
          8     BLANK     (read next command)

THALG     4     ALGST     (SADRES := LA-ALGST+OFFSET)
          2     LA
          1     INTEGR
          5     SADRES

          4     LBASE     (ALGST-LBASE+LOW1+LASTSZ)
          2     ALGST
          1     LOW1
          1     LASTSZ
          11    SUBSTI    (fix up reference chain)
          8     ENTRY-1
          8     BLANK

(100 Name 1  Declare identifier
  001 Name 2
  Identifier is a label for current value of LA.
  100 Name 1  Reference identifier
  010 Name 2
      F Increment
  Store into [LA] an instruction with an
  identified address F Name 1 Name 2 + increment,
  putting a link address in store if Name 1 Name 2
  is unlocated; LA+:= 1
  100
  other  Error FD)

FOUR      11    READTH    (read three rows)
          8     READTH+1
          4     LW3
          1     -3
          9     ;+3       (check code <= 3)
          4     +4
          8     FAIL      (signal fail FD)

          0     LW3
          /8    ;+1       (branch on code)
          8     ;-4
          8     TONE
          8     TTWO

FAIL1     4     +1        (fail with code FA)
          8     FAIL

(111 Word  Halt
        If Word = 15 do thunk processing
  If Word = 0 print FIRST & NEXT addresses and
  If Word > 8 jump to this absolute address
  Otherwise set option := Word and continue)

HALT      4     LOW1      (read rest of word)
          15    2048
          15    2048
          0     +THUNK
          1     -15
          /7    0
          4     BD        (scan dictionary for unlocated globals)
          5     DP        (DP := BD)
          8     BLAST

RETURN    0     DP
          /4    1
          6     =/15 0
          2     =/15 0
          7     ;+3       ([DP+1] = /15 xxxx?)

          /4    0
          9     MESS      ([DP] < 0)

NEXT      4     DP        (DP := DP+3)
          1     +3
          5     DP

BLAST     1     EDNEG     (all dictionary scanned?)
          7     END       (DP = EDNEG?)
          8     RETURN    (continue scanning)

MESS      /4    1         (report global unlocated [FU])
          5     NAM1
          /4    2
          5     NAM2
          4     :RET1
 	  0     MMODUL
          /5    SBLNK2
          4     :MESAGE
RET1      /8    OSTSB
          8     NEXT      (continue scanning)

(there used to be a check for options here but we have abandoned it)

(end of loading: print FIRST NEXT message)
END       4     :RET2
          0     MMODUL
          /5    SBLNK2
          4     :FINAL
RET2      /8    OSTSB
          4     :RET3
          0	MMODUL
          /5    IOLNK
          4     FIRST
RET3      /8    OUTI+5
          4     :RET4
	  0     MMODUL
          /5    SBLNK2
          4     :INTER
RET4      /8    OSTSB
          4     :RET5
	  0	MMODUL
          /5    IOLNK
          4     LA
RET5      /8    OUTI+5

          0     MODE
          /8    ;+0
          8     M123      (load ALGOL)
          8     M123      (load ALGOL overwriting code procs)
          8     M123      (load ALGOL overwriting procs and library)
          8     M45       (load code proc)
          8     M45       (load code proc overwriting others)
          8     M6        (reload library)

M123      4     LA        (loading ALGOL)
          0     MMODUL
          /5    STKBASE   (STKBASE := LA)
          /4    BASE+1    (QACODL := QACODL+BASE))
          1     LBASE
          /5    BASE+1 
          /4    BASE+2    (QAVANDA = QAVANDA+BASE)
          1     LBASE
          /5    BASE+2    
          4     +0
          5     ALGFLG    (reset ALGFLG)
          /4    OLDLBD
          1     PMODUL
          /5    WARNAD+1  (WARNAD+1 := OLDLBD+PMODUL)
          4     +6
          2     CONST
          1     PMODUL
          /5    WARNAD    (WARNAD := CONST-6 absolute)
          4     DICT
          1     PMODUL
          /5    WARNAD+2  (PDADD := DICT absolute)
          /8    LPCTL     (return to interpreter)

M45       4     LA        (loading code procs)
          0     MMODUL
          /5    STKMOD    (STKMOD := LA)
          5     LIBEND    (LIBEND := LA)
          4     BD
          5     LASTBD    (LASTBD := BD)
          5     DICT      (DICT := BD)
          8     ;+0

M6        4     LA        (loading library)
          0     MMODUL
          /5    STKMOD    (STKMOD := PROGM := LIBEND := LA)
          5     PROGM
          5     LIBEND
          4     BD
          5     LASTBD    (LASTBD := BD)
          /5    OLDLBD    (OLDLBD := BD)
          8     ;+0

(110 Integer  Verify checksum
  Verify Integer = sum of 7 bit tape characters
  read (excluding codes 6 & 7 since last START)

TEST      4     LOW1      (read in rest of word - checksum)
          15    2048
          15    2048
          2     CR        (CR = checksum?)
          7     ST2       (checksum ok)
          4     +6        (give error FF)
          8     FAIL

ST2       4     BA        (LASTSZ := LA-BA)
          2     LA
          5     LASTSZ
          8     CLRCR     (clear checksum and continue reading)

MODE      >1
ALGST     >1              (start of ALGOL program)
LBASE     >1
PMODUL    >1		  (Module address of loader)
MMODUL    >1		  (Module address of interpreter)
CONST     +BEGLOA
BD        >1
OPTION    >1
LA        >1
W         >1
FIRST     >1
ED        >1
EDNEG     >1
BA        >1
LASTSZ    >1              (size of last block loaded)
CR        >1              (checksum)
NULL      &074000         (null prefix)
LOW1      >1
LOW       >1
PROGM     >1              (first free location for program after library)
LIBEND    :ENDLIB         (end of standard library + 1)
LASTBD    +LPSYMS         (base of current dictionary)
DICT      +BEGLOA-6       (base of empty dictionary)
ALGFLG    +0              (set to +1 by interpreter when loading ALGOL,
                            and reset to +0 afterwards)
INTEGR    >1
SADRES    >1
LW3       >1              (AJH mod: was W+3)
DP        >1

MESAGE    \'^F
          \U
NAM1      +0
NAM2      +0
          \@

FINAL     \'^
          \FIR
          \ST
          \  N
          \EXT
          \^@

INTER     \'
          \@

[ BD E5TEST FAIL LA MMODUL PMODUL RET6 MSG OSTSB SBLNK2 ]

(check loaded code is below dictionary)

E5TEST    >1
          4     PMODUL
          1     BD
          2     LA
          9     EXIT      ([LA-PMODUL]-BD < 0 ok)
          4     +5        (store full - report FE)
FAIL      0     +0
          14    12
          1     &404000
          5     LIVE
          4     :RET6
          0     MMODUL
          /5    SBLNK2
          4     MSG
RET6      /8    OSTSB
          8     ;+0

EXIT      0     E5TEST
          /8    1

MSG       \'^F
LIVE      +0

[ CR INTEGR READTH W ]

(read three rows into INTEGR, type in INTEGR+2)
READTH    >1
          4     -3
          5     W

REPEAT    4     INTEGR
          15    2048
          5     INTEGR
          6     +127
          1     CR
          5     CR
          4     W
          2     -3
          7     FIRST

RETURN    10    W
          4     W
          9     REPEAT
          0     READTH
          /8    1

FIRST     4     INTEGR
          14    8188
          6     +7
          5     INTEGR+2
          8     RETURN

[ BD DP EDNEG E5TEST LA NAMONE NAMTWO SEARCH LBASE MMODUL ]

(scan dictionary for NAMONE, NAMTWO
  dictionary entries:
    address    bit18 set if unknown, else
                     address relative to BASE
          NAMONE
          NAMTWO)

SEARCH    >1
          4     BD        (DP := BD // bottom of dict)
          5     DP

RETURN    1     EDNEG
          7     PLACE     (DP = ED // reached end of dictionary)
          0     DP
          /4    1         ([DP+1] = NAMONE?)
          2     NAMONE
          7     WD2

REPEAT    4     DP        (DP +:= 3 // next entry)
          1     +3
          5     DP
          8     RETURN

WD2       /4    2
          2     NAMTWO
          0     SEARCH
          /7    1         (return if NAMTWO matches)
          8     REPEAT

PLACE     4     BD        (not found, add to dictionary)
          1     -3
          5     BD        (BD -:= 3 // space for new entry)
          5     DP
          11    E5TEST    (check not collided with code)
          8     E5TEST+1
          4     LBASE     (WS1 := LA-BASE)
          2     LA
          5     WS1
          0     SEARCH
          /4    2         (parameter)
          1     WS1
          0     BD
          /5    0         ([BD] := parameter+LA-BASE // relative)

          4     NAMONE
          /5    1         ([BD+1] := NAMONE)
          4     NAMTWO
          /5    2         ([BD+2] := NAMTWO)

          0     SEARCH
          /8    3

WS1       +0

[ DP ENTRY SADRES SUBSTI LBASE MMODUL ALGFLG ]

(fix up relocation chain with SADRES
  SADRES is address relative to BASE)

SUBSTI    >1
          0     DP        (SWORK := [DP] & &377777)
          /4    0
          6     =15 8191
          5     SWORK
          4     SADRES
          /5    0         ([DP] := SADRES // update dictionary)

RETURN    4     SWORK
          2     +8191

EXIT      0     SUBSTI
          /7    1         (SWORK = 8191 // end of chain)
          4     SWORK
          1     LBASE     (SWORK+BASE)

ENTRY     1     MMODUL    (+MMODULE // make address module relative)
          5     SWORK
          0     SWORK
          /4    0         (next := [SWORK] & 8191)
          6     +8191
          5     SWORK
          4     ALGFLG    (loading ALGOL?)
          7     SUBCOD
          4     SWORK     (ALGOL)
          /2    0         ([SWORK] - next)
          8     NEXT

SUBCOD    4     SWORK     ([SWORK] - next + BASE)
          /2    0
          1     LBASE

NEXT      1     SADRES    (add SADRES)
          /5    0         (store in [SWORK])
          4     SWORK
          2     +8191     (return if SWORK = 8191)
          0     SUBSTI
          /7    1
          4     SWORK     (otherwise follow chain)
          8     ENTRY

SWORK     +0

[ BLANK CLENUP DP FAIL INTEGR LA NAMONE NAMTWO OPTION SADRES SEARCH SUBSTI TONE
LOW1 LBASE SBLNK2 OSTSB MMODUL NAMSTR IOLNK OUTI RET7 RET8 ]

(100 Name 1  Declare identifier
  001 Name 2
  Identifier is a label for current value of LA)

TONE      4     LOW1
          5     NAMONE
          4     INTEGR
          5     NAMTWO
          4     OPTION
          6     +1
          7     DONT
          4     :RET7
          0     MMODUL
          /5    SBLNK2
          4     :NAMSTR
RET7      /8    OSTSB
	  0	MMODUL
          4     :RET8
          /5    IOLNK
          4     LA
RET8      /8    OUTI+5

DONT      11    SEARCH    (look up in dictionary)
          8     SEARCH+1
          8     FOUND
          +0              (enter 0 as address)
          8     BLANK

FOUND     0     DP
          /4    0
          9     ;+3       ([DP] < 0 if unset)
          4     +3        (report FC fail for duplicate)
          8     FAIL

          4     LBASE     (SADRES := LA-BASE // LA relative to BASE)
          2     LA
          5     SADRES
          11    SUBSTI    (fix up chain)
          8     SUBSTI+1
          11    CLENUP
          8     CLENUP+1
          8     BLANK     (read next command)

NAMSTR    \'^
NAMONE    +0
NAMTWO    +0
          \@

[ DP INCR INTEGR LA NAMONE NAMTWO READTH SEARCH STET TTWO W MODE LBASE LOW1
ALGFLG FAIL ]

(100 Name 1  Reference identifier
  010 Name 2
      F Increment
  Store into [LA] an instruction with an
  identified address F Name 1 Name 2 + increment,
  putting a link address in store if Name 1 Name 2
  is unlocated; LA+:= 1)

TASIR     4     =15 0     (modified INOUT)
          8     ;+2
CFSIR     4     =/14 0    (modified PEM)
          1     +32
          5     WS
          8     NORML1

TTWO      4     INTEGR
          5     NAMTWO
          11    READTH
          8     READTH+1
          4     INTEGR
          5     WS
          4     ALGFLG    (check if processing Algol)
          7     NORML1    (handle code procedure / library)
          4     WS        (check for CF or TA)
          7     TASIR
          2     =/5 0     (convert CF into CFSIR)
          7     CFSIR

NORML1    11    READTH
          8     READTH+1
          4     LOW1
          5     NAMONE
          11    SEARCH    (look up name)
          8     SEARCH+1
          8     FOUND1    (already referenced)
          /0    0         (not referenced - set entry to /0 0)
          4     INTEGR    (is there an increment?)
          7     NOICR
          4     =/0 8191  (yes, set entry to /0 8191)
          0     DP
          /5    0
          4     INTEGR

INCR      5     NAMTWO
          4     DP
          1     =/15 0
          5     NAMONE
          11    SEARCH
          8     SEARCH+1
          8     FOUND
          /0    0

NOICR     4     +8191

EXTEND    1     WS
          8     STET

FOUND     0     DP        (increment already in dictionary)
          /4    0
          5     WS+1
          4     LBASE
          2     LA
          1     =/0 0
          /5    0         (head of chain := /0 LA-LBASE)
          4     WS+1
          6     +8191
          5     WS+1      (previous head of chain)
          4     ALGFLG
          7     NALG
ALG       4     WS+1
          8     EXTEND

NALG      4     WS+1      (if end of chain, leave alone)
          2     +8191
          7     ALG
          4     LBASE
          1     WS+1
          8     EXTEND

FOUND1    0     DP        (name already in dictionary)
          /4    0
          9     NORML2    (but not located)
          1     INTEGR    (address + increment)
          1     WS        (op code)
          5     WS+1      (instruction relative to LBASE)
          4     ALGFLG    (loading Algol?)
          7     ;+3       (no)
          4     WS+1      (yes - store as is)
          8     STET

          /4    0         (Algol so check address < 8159)
          1     INTEGR
          2     +8159
          9     FGERR
          4     LBASE     (make absolute)
          1     WS+1
          8     STET

NORML2    4     INTEGR    (is there an increment?)
          7     FOUND     (no)
          8     INCR      (yes)

FGERR     4     +7        (signal error FG)
          8     FAIL

WS        >3

[ BD CLENUP DP ED LA SADRES SUBSTI LBASE ]

(search for other increments of current
  dictionary entry [DP] and fix up)

CLENUP    >1
          4     DP        (W := DP-8192)
          1     -8192
          5     W
          4     ED
          5     DP        (DP := ED)

RETURN    0     DP
          /4    1
          2     W
          7     FOUND     ([DP+1] = W?)

REPEAT    4     DP        (DP := DP-3)
          1     -3
          5     DP
          2     BD
          9     RETURN    (DP >= BD, continue)
          7     RETURN

EXIT      0     CLENUP
          /8    1

FOUND     4     LBASE
          2     LA
          0     DP
          /1    2         (SADRES := [DP]+LA-BASE)
          5     SADRES
          11    SUBSTI    (fix up)
          8     SUBSTI+1
          8     REPEAT    (do next)

W=8191^1

%

<! Halt !>