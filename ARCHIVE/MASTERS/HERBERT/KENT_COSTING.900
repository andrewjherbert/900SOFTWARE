
C KENT PRIZE UPDATE PROGRAM.  A.J. HERBERT 15/07/2012.
C
C READS A TAPE OF ASSEMBLIES TO BE COSTED USING A TAPE OF 
C COMPONENT PRICES.
C
C THE COMPONENT PRICE TAPE CONTAINS RECORDS OF THE FORM: 
C AA1234       1.23
C WHERE AA1234 IS A COMPONENT NAME COMPRISING TWO LETTERS AND FOUR 
C DIGITS AND 1.23 IS A PRICE IN POUNDS AND PENCE, 
C 0.00 <= PRICE <= 999.99.
C THE COMPONENT NAME [[ 9999 IS USED AS AN END OF FILE SENTINEL.
C
C THE ASSEMBLY TAPE CONSISTS OF RECORDS OF THE FORM:
C ASSEMBLY NO. 37P68 
C   NO.          QTY
C AA1234          6
C BB2323         10
C CC8891          5
C [[[]]]          0
C WHERE 37p68 IS THE ASSEMBLY NAME, THEN AA1234 ETC ARE COMPONENT 
C NAMES TO BE LOOKED UP IN THE COMPONENT FILE AND 6, 10, 5 ARE THE 
C qUANTITIES OF EACH COMPONENT USED IN THE ASSEMBLY.  THE FINAL LINE 
C IS A END OF FILE SENTINEL.
C
C THE COMPONENT FILE IS REPRESENTED INTERNALLY AS A TWO DIMENSIONAL 
C ARRAY WITH COLUMN 1 CONTAINING THE COMPONENT NAME LETTERS, COLUMN
C 2 THE COMPONENT DIGITS AND COLUMN 3 THE PRICE IN PENCE.
C
C THE PROGRAM READS IN THE COMPONENT TAPE, THEN READS IN THE ASSEMBLY 
C TAPE AND COMPUTES A COST FOR THE ASSEMBLY.
C
C LIMITATIONS:
C	UPDATE TAPE CANNOT CONTAIN MORE THAN 1500 RECORDS.
C
C
C MAIN PROGRAM
C
C
      INTEGER PRICES(3, 1500), NAME(6), DIGS(4)
      INTEGER PRICNT, PRIMAX
      INTEGER ERRORS
      INTEGER PNAM, PDIGS
      INTEGER CNAM, CDIGS
      INTEGER ANAM1, ANAM2
      INTEGER POUND, PENCE, QTY
      INTEGER CPRICE, APRICE
      INTEGER SENT1, SENT2
      INTEGER LETA, LETZ, SPC, DIG0, DIG9
      INTEGER LO, HI, MID
      REAL    PRICE, TOTAL
C
C     ...PUT PRICES ARRAY IN COMMON TO REDUCE PROGRAM SIZE
      COMMON / ARRAYS / PRICES
      COMMON DIGS
C
      DATA PRIMAX / 1500 /, SENT1, SENT2 / 2H[[, 9999 /
      DATA LETA, LETZ, SPC, DIG0, DIG9 / 1HA, 1HZ, 1H , 1H0, 1H9 /
C
C     ...ANNOUNCE PROGRAM
      WRITE (3, 903)
  903 FORMAT (38HKENT PROGRAMMING PRIZE COSTING PROGRAM/
     1        25HANDREW HERBERT 15/07/2012)
C
C     ...INSTRUCT OPERATOR TO LOAD PRICES TAPE
      WRITE (3, 900)
  900 FORMAT (//22H***LOAD PRICES TAPE***//)
      PAUSE 
C
C     ...READ IN PRICES, COUNTING IN PRICNT
      PRICNT = 0
   10 READ  (1, 910) PNAM, PDIGS, PRICE
  910 FORMAT (A2, 1X, I4, F7.2)
C
C     ...BUILD PRICES FILE
      PRICNT = PRICNT + 1
      PRICES(1,PRICNT) = PNAM
      PRICES(2,PRICNT) = PDIGS
      PRICES(3,PRICNT) = PRICE * 100.0
C
C     ...LOOK FOR SENTINEL
      IF (      PNAM  .EQ. SENT1
     1    .AND. PDIGS .EQ. SENT2 ) GOTO 100
C
C     ...LOOP BACK TO READ NEXT PRICE
      IF ( PRICNT .LT. PRIMAX ) GOTO 10
C
C     ...PRICE FILE OVERFLOWED
      WRITE (3, 920) PRIMAX
  920 FORMAT (22HABANDONED - MORE THAN , I6, 21HRECORDS ON PRICE TAPE)
C
C     ...PRICE FILE COMPLETE,
C     ...TELL OPERATOR TO LOAD ASSEMBLY TAPE
  100 WRITE (3, 930) PRICNT
  930 FORMAT (//19HPRICES FILE READ - , I6, 8H RECORDS///
     1        24H***LOAD ASSEMBLY TAPE***//)
      PAUSE
C
C     ...READ ASSEMBLY NAME
      READ (1, 940) (NAME(I), I = 1, 5)
  940 FORMAT (13X, 5A1//)
C
C     ...VERIFY ASSEMBLY NAME
      IF ( NAME(1) .LT. DIG0 ) GOTO 110
      IF ( NAME(1) .GT. DIG9 ) GOTO 110
      IF ( NAME(2) .LT. DIG0 ) GOTO 110
      IF ( NAME(2) .GT. DIG9 ) GOTO 110
      IF ( NAME(3) .LT. LETA ) GOTO 110
      IF ( NAME(3) .GT. LETZ ) GOTO 110
      IF ( NAME(4) .LT. DIG0 ) GOTO 110
      IF ( NAME(4) .GT. DIG9 ) GOTO 110
      IF ( NAME(5) .LT. DIG0 ) GOTO 110
      IF ( NAME(5) .GT. DIG9 ) GOTO 110
C
C     ...NAME OK, PACK INTO ANAM1, ANAM2
      CODE
	4	NAME+1
	6	&770000
	14 	8186
	1	NAME
	5	ANAM1
	4	NAME+2
	6	&770000
	14	8180
	1	ANAM1
	5	ANAM1
        4	NAME+3
	6	&770000
	5	ANAM2
	4	NAME+4
	6	&770000
	14	8186
	1	ANAM2
	5	ANAM2
      FORTRAN
      GOTO 120
C
C     ...INCORRECT ASSEMBLY NAME
  110 WRITE (3, 945) ANAM1, ANAM2
  945 FORMAT (25HINCORRECT ASSEMBLY NAME: , 2A3//
     1        13HRUN ABANDONED//)
      STOP
C
C     ...ASSEMBLY NAME OK
  120 WRITE (3, 950) ANAM1, ANAM2
  950 FORMAT (9HASSEMBLY , 2A3//
     1        9HCOMPONENT, 3X, 3HQTY, 5X, 4HCOST/)
C
C     ...HOUSEKEEPING
      TOTAL  = 0.0
      PRICNT = PRICNT - 1
      ERRORS = 0
C
C     ...READ EACH COMPONENT AND QUANTITY
  200 READ (1, 960) CNAM, CDIGS, QTY
  960 FORMAT (A2, 1X, I4, I6)
      IF (       CNAM  .EQ. SENT1
     1     .AND. CDIGS .EQ. SENT2 ) GOTO 300
C
C     ...SPLIT OUR DIGITS IN NAME
      CALL DIGITS (CDIGS)
C
C     ...VALIDATE QTY
      IF ( QTY .GT. 0 ) GOTO 205
C
C     ...REJECT NEGATIVE QTY
      ERRORS = ERRORS + 1
      WRITE (3, 965) CNAM, (DIGS(I),I=1,4), QTY
  965 FORMAT (A3, 4I1, I8, 13X, 17HQUANTITY REJECTED)
      QTY = 0
C
C     ...FIND COMPONENT IN FILE USING BINARY CHOP
 205  LO  = 1
      HI  = PRICNT
 210  MID = (LO + HI) / 2
      IF (       CNAM  .EQ. PRICES(1,MID)
     1     .AND. CDIGS .EQ. PRICES(2,MID) ) GOTO 240
      IF ( HI .EQ. LO ) GOTO 230
      IF (       CNAM  .LT. PRICES(1,MID) ) GOTO 220
      IF (       CNAM  .EQ. PRICES(1,MID) 
     1     .AND. CDIGS .LT. PRICES(2,MID) ) GOTO 220
C
C     ...HERE TO SEARCH TOP HALF
      LO = MID  + 1
      GOTO 210
C
C     ...HERE TO SEARCH BOTTOM HALF
  220 HI = MID - 1
      GOTO 210
C
C     ...IF HERE COMPONENT NOT FOUND
  230 ERRORS = ERRORS + 1
      WRITE (3, 970) CNAM, (DIGS(I),I=1,4), QTY
  970 FORMAT (A3, 4I1, I8, 13X, 19HCOMPONENT NOT FOUND)
      GOTO 200
C
C     ...COMPONENT FOUND, LIST UNLESS QTY IS ZERO
  240 IF ( QTY .EQ. 0 ) GOTO 200
      PRICE = (QTY * PRICES(3,MID)) / 100
      TOTAL = TOTAL + PRICE
      WRITE (3, 980) CNAM, (DIGS(I),I=1,4), QTY, PRICE
  980 FORMAT (A2, 1X, 4I1, I8, F9.2)
C
C     ...LOOP BACK FOR NEXT RECORD
      GOTO 200
C
C     ...ASSEMBLY COMPLETE, PUNCH TOTAL
      
  300 IF ( ERRORS .GT. 0 ) GOTO 400
C
C     ...NO ERRORS FOUND, PRINT TOTAL
      WRITE (3, 990) TOTAL
  990 FORMAT (/13HTOTAL COST = , F11.2//)
      STOP
C
C     ...ERRORS WERE FOUND
  400 WRITE (3, 995) ERRORS
  995 FORMAT (/13HRUN ABANDONED, I5, 14H ERRRORS FOUND//)
      STOP
      END 
C
C
C SUBROUTINE TO BREAK 4 DIGIT INTEGER INTO SINGLE DIGITS
C
C
      SUBROUTINE DIGITS (NUM)
      INTEGER DIGS(4)
      INTEGER NUM, N
      COMMON DIGS
      N = NUM
      DIGS(1) = N / 1000
      N = N - DIGS(1) * 1000 
      DIGS(2) = N / 100
      N = N - DIGS(2) * 100
      DIGS(3) = N /10
      DIGS(4) = N - DIGS(3) * 10
      RETURN
      END   
<! HALT !>